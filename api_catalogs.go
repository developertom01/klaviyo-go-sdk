/*
Klaviyo API

The Klaviyo REST API. Please visit https://developers.klaviyo.com for more details.

API version: 2024-02-15
Contact: developers@klaviyo.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package klaviyo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// CatalogsAPIService CatalogsAPI service
type CatalogsAPIService service

type ApiCreateBackInStockSubscriptionRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	serverBISSubscriptionCreateQuery *ServerBISSubscriptionCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiCreateBackInStockSubscriptionRequest) Revision(revision string) ApiCreateBackInStockSubscriptionRequest {
	r.revision = &revision
	return r
}

func (r ApiCreateBackInStockSubscriptionRequest) ServerBISSubscriptionCreateQuery(serverBISSubscriptionCreateQuery ServerBISSubscriptionCreateQuery) ApiCreateBackInStockSubscriptionRequest {
	r.serverBISSubscriptionCreateQuery = &serverBISSubscriptionCreateQuery
	return r
}

func (r ApiCreateBackInStockSubscriptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateBackInStockSubscriptionExecute(r)
}

/*
CreateBackInStockSubscription Create Back In Stock Subscription

Subscribe a profile to receive back in stock notifications. Check out [our Back in Stock API guide](https://developers.klaviyo.com/en/docs/how_to_set_up_custom_back_in_stock) for more details.

This endpoint is specifically designed to be called from server-side applications. To create subscriptions from client-side contexts, use [POST /client/back-in-stock-subscriptions](https://developers.klaviyo.com/en/reference/create_client_back_in_stock_subscription).<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:write`
`profiles:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBackInStockSubscriptionRequest
*/
func (a *CatalogsAPIService) CreateBackInStockSubscription(ctx context.Context) ApiCreateBackInStockSubscriptionRequest {
	return ApiCreateBackInStockSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CatalogsAPIService) CreateBackInStockSubscriptionExecute(r ApiCreateBackInStockSubscriptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.CreateBackInStockSubscription")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/back-in-stock-subscriptions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.serverBISSubscriptionCreateQuery == nil {
		return nil, reportError("serverBISSubscriptionCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.serverBISSubscriptionCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateCatalogCategoryRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogCategoryCreateQuery *CatalogCategoryCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiCreateCatalogCategoryRequest) Revision(revision string) ApiCreateCatalogCategoryRequest {
	r.revision = &revision
	return r
}

func (r ApiCreateCatalogCategoryRequest) CatalogCategoryCreateQuery(catalogCategoryCreateQuery CatalogCategoryCreateQuery) ApiCreateCatalogCategoryRequest {
	r.catalogCategoryCreateQuery = &catalogCategoryCreateQuery
	return r
}

func (r ApiCreateCatalogCategoryRequest) Execute() (*PostCatalogCategoryResponse, *http.Response, error) {
	return r.ApiService.CreateCatalogCategoryExecute(r)
}

/*
CreateCatalogCategory Create Catalog Category

Create a new catalog category.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCatalogCategoryRequest
*/
func (a *CatalogsAPIService) CreateCatalogCategory(ctx context.Context) ApiCreateCatalogCategoryRequest {
	return ApiCreateCatalogCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogCategoryResponse
func (a *CatalogsAPIService) CreateCatalogCategoryExecute(r ApiCreateCatalogCategoryRequest) (*PostCatalogCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.CreateCatalogCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-categories/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogCategoryCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogCategoryCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogCategoryCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCatalogCategoryRelationshipsItemsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	catalogCategoryItemOp *CatalogCategoryItemOp
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiCreateCatalogCategoryRelationshipsItemsRequest) Revision(revision string) ApiCreateCatalogCategoryRelationshipsItemsRequest {
	r.revision = &revision
	return r
}

func (r ApiCreateCatalogCategoryRelationshipsItemsRequest) CatalogCategoryItemOp(catalogCategoryItemOp CatalogCategoryItemOp) ApiCreateCatalogCategoryRelationshipsItemsRequest {
	r.catalogCategoryItemOp = &catalogCategoryItemOp
	return r
}

func (r ApiCreateCatalogCategoryRelationshipsItemsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateCatalogCategoryRelationshipsItemsExecute(r)
}

/*
CreateCatalogCategoryRelationshipsItems Create Catalog Category Relationships Items

Create a new item relationship for the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiCreateCatalogCategoryRelationshipsItemsRequest
*/
func (a *CatalogsAPIService) CreateCatalogCategoryRelationshipsItems(ctx context.Context, id string) ApiCreateCatalogCategoryRelationshipsItemsRequest {
	return ApiCreateCatalogCategoryRelationshipsItemsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CatalogsAPIService) CreateCatalogCategoryRelationshipsItemsExecute(r ApiCreateCatalogCategoryRelationshipsItemsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.CreateCatalogCategoryRelationshipsItems")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-categories/{id}/relationships/items/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.catalogCategoryItemOp == nil {
		return nil, reportError("catalogCategoryItemOp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogCategoryItemOp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateCatalogItemRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogItemCreateQuery *CatalogItemCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiCreateCatalogItemRequest) Revision(revision string) ApiCreateCatalogItemRequest {
	r.revision = &revision
	return r
}

func (r ApiCreateCatalogItemRequest) CatalogItemCreateQuery(catalogItemCreateQuery CatalogItemCreateQuery) ApiCreateCatalogItemRequest {
	r.catalogItemCreateQuery = &catalogItemCreateQuery
	return r
}

func (r ApiCreateCatalogItemRequest) Execute() (*PostCatalogItemResponse, *http.Response, error) {
	return r.ApiService.CreateCatalogItemExecute(r)
}

/*
CreateCatalogItem Create Catalog Item

Create a new catalog item.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCatalogItemRequest
*/
func (a *CatalogsAPIService) CreateCatalogItem(ctx context.Context) ApiCreateCatalogItemRequest {
	return ApiCreateCatalogItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogItemResponse
func (a *CatalogsAPIService) CreateCatalogItemExecute(r ApiCreateCatalogItemRequest) (*PostCatalogItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.CreateCatalogItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogItemCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogItemCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogItemCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCatalogItemRelationshipsCategoriesRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	catalogItemCategoryOp *CatalogItemCategoryOp
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiCreateCatalogItemRelationshipsCategoriesRequest) Revision(revision string) ApiCreateCatalogItemRelationshipsCategoriesRequest {
	r.revision = &revision
	return r
}

func (r ApiCreateCatalogItemRelationshipsCategoriesRequest) CatalogItemCategoryOp(catalogItemCategoryOp CatalogItemCategoryOp) ApiCreateCatalogItemRelationshipsCategoriesRequest {
	r.catalogItemCategoryOp = &catalogItemCategoryOp
	return r
}

func (r ApiCreateCatalogItemRelationshipsCategoriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateCatalogItemRelationshipsCategoriesExecute(r)
}

/*
CreateCatalogItemRelationshipsCategories Create Catalog Item Relationships Categories

Create a new catalog category relationship for the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiCreateCatalogItemRelationshipsCategoriesRequest
*/
func (a *CatalogsAPIService) CreateCatalogItemRelationshipsCategories(ctx context.Context, id string) ApiCreateCatalogItemRelationshipsCategoriesRequest {
	return ApiCreateCatalogItemRelationshipsCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CatalogsAPIService) CreateCatalogItemRelationshipsCategoriesExecute(r ApiCreateCatalogItemRelationshipsCategoriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.CreateCatalogItemRelationshipsCategories")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-items/{id}/relationships/categories/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.catalogItemCategoryOp == nil {
		return nil, reportError("catalogItemCategoryOp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogItemCategoryOp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateCatalogVariantRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogVariantCreateQuery *CatalogVariantCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiCreateCatalogVariantRequest) Revision(revision string) ApiCreateCatalogVariantRequest {
	r.revision = &revision
	return r
}

func (r ApiCreateCatalogVariantRequest) CatalogVariantCreateQuery(catalogVariantCreateQuery CatalogVariantCreateQuery) ApiCreateCatalogVariantRequest {
	r.catalogVariantCreateQuery = &catalogVariantCreateQuery
	return r
}

func (r ApiCreateCatalogVariantRequest) Execute() (*PostCatalogVariantResponse, *http.Response, error) {
	return r.ApiService.CreateCatalogVariantExecute(r)
}

/*
CreateCatalogVariant Create Catalog Variant

Create a new variant for a related catalog item.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCatalogVariantRequest
*/
func (a *CatalogsAPIService) CreateCatalogVariant(ctx context.Context) ApiCreateCatalogVariantRequest {
	return ApiCreateCatalogVariantRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogVariantResponse
func (a *CatalogsAPIService) CreateCatalogVariantExecute(r ApiCreateCatalogVariantRequest) (*PostCatalogVariantResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogVariantResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.CreateCatalogVariant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogVariantCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogVariantCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogVariantCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCatalogCategoryRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiDeleteCatalogCategoryRequest) Revision(revision string) ApiDeleteCatalogCategoryRequest {
	r.revision = &revision
	return r
}

func (r ApiDeleteCatalogCategoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCatalogCategoryExecute(r)
}

/*
DeleteCatalogCategory Delete Catalog Category

Delete a catalog category using the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The catalog category ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
 @return ApiDeleteCatalogCategoryRequest
*/
func (a *CatalogsAPIService) DeleteCatalogCategory(ctx context.Context, id string) ApiDeleteCatalogCategoryRequest {
	return ApiDeleteCatalogCategoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CatalogsAPIService) DeleteCatalogCategoryExecute(r ApiDeleteCatalogCategoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.DeleteCatalogCategory")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-categories/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCatalogCategoryRelationshipsItemsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	catalogCategoryItemOp *CatalogCategoryItemOp
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiDeleteCatalogCategoryRelationshipsItemsRequest) Revision(revision string) ApiDeleteCatalogCategoryRelationshipsItemsRequest {
	r.revision = &revision
	return r
}

func (r ApiDeleteCatalogCategoryRelationshipsItemsRequest) CatalogCategoryItemOp(catalogCategoryItemOp CatalogCategoryItemOp) ApiDeleteCatalogCategoryRelationshipsItemsRequest {
	r.catalogCategoryItemOp = &catalogCategoryItemOp
	return r
}

func (r ApiDeleteCatalogCategoryRelationshipsItemsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCatalogCategoryRelationshipsItemsExecute(r)
}

/*
DeleteCatalogCategoryRelationshipsItems Delete Catalog Category Relationships Items

Delete item relationships for the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiDeleteCatalogCategoryRelationshipsItemsRequest
*/
func (a *CatalogsAPIService) DeleteCatalogCategoryRelationshipsItems(ctx context.Context, id string) ApiDeleteCatalogCategoryRelationshipsItemsRequest {
	return ApiDeleteCatalogCategoryRelationshipsItemsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CatalogsAPIService) DeleteCatalogCategoryRelationshipsItemsExecute(r ApiDeleteCatalogCategoryRelationshipsItemsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.DeleteCatalogCategoryRelationshipsItems")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-categories/{id}/relationships/items/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.catalogCategoryItemOp == nil {
		return nil, reportError("catalogCategoryItemOp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogCategoryItemOp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCatalogItemRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiDeleteCatalogItemRequest) Revision(revision string) ApiDeleteCatalogItemRequest {
	r.revision = &revision
	return r
}

func (r ApiDeleteCatalogItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCatalogItemExecute(r)
}

/*
DeleteCatalogItem Delete Catalog Item

Delete a catalog item with the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The catalog item ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
 @return ApiDeleteCatalogItemRequest
*/
func (a *CatalogsAPIService) DeleteCatalogItem(ctx context.Context, id string) ApiDeleteCatalogItemRequest {
	return ApiDeleteCatalogItemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CatalogsAPIService) DeleteCatalogItemExecute(r ApiDeleteCatalogItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.DeleteCatalogItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCatalogItemRelationshipsCategoriesRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	catalogItemCategoryOp *CatalogItemCategoryOp
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiDeleteCatalogItemRelationshipsCategoriesRequest) Revision(revision string) ApiDeleteCatalogItemRelationshipsCategoriesRequest {
	r.revision = &revision
	return r
}

func (r ApiDeleteCatalogItemRelationshipsCategoriesRequest) CatalogItemCategoryOp(catalogItemCategoryOp CatalogItemCategoryOp) ApiDeleteCatalogItemRelationshipsCategoriesRequest {
	r.catalogItemCategoryOp = &catalogItemCategoryOp
	return r
}

func (r ApiDeleteCatalogItemRelationshipsCategoriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCatalogItemRelationshipsCategoriesExecute(r)
}

/*
DeleteCatalogItemRelationshipsCategories Delete Catalog Item Relationships Categories

Delete catalog category relationships for the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiDeleteCatalogItemRelationshipsCategoriesRequest
*/
func (a *CatalogsAPIService) DeleteCatalogItemRelationshipsCategories(ctx context.Context, id string) ApiDeleteCatalogItemRelationshipsCategoriesRequest {
	return ApiDeleteCatalogItemRelationshipsCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CatalogsAPIService) DeleteCatalogItemRelationshipsCategoriesExecute(r ApiDeleteCatalogItemRelationshipsCategoriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.DeleteCatalogItemRelationshipsCategories")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-items/{id}/relationships/categories/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.catalogItemCategoryOp == nil {
		return nil, reportError("catalogItemCategoryOp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogItemCategoryOp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCatalogVariantRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiDeleteCatalogVariantRequest) Revision(revision string) ApiDeleteCatalogVariantRequest {
	r.revision = &revision
	return r
}

func (r ApiDeleteCatalogVariantRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCatalogVariantExecute(r)
}

/*
DeleteCatalogVariant Delete Catalog Variant

Delete a catalog item variant with the given variant ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The catalog variant ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
 @return ApiDeleteCatalogVariantRequest
*/
func (a *CatalogsAPIService) DeleteCatalogVariant(ctx context.Context, id string) ApiDeleteCatalogVariantRequest {
	return ApiDeleteCatalogVariantRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CatalogsAPIService) DeleteCatalogVariantExecute(r ApiDeleteCatalogVariantRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.DeleteCatalogVariant")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variants/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCatalogCategoriesRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogCategory *[]string
	filter *string
	pageCursor *string
	sort *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCatalogCategoriesRequest) Revision(revision string) ApiGetCatalogCategoriesRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogCategoriesRequest) FieldsCatalogCategory(fieldsCatalogCategory []string) ApiGetCatalogCategoriesRequest {
	r.fieldsCatalogCategory = &fieldsCatalogCategory
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;ids&#x60;: &#x60;any&#x60;&lt;br&gt;&#x60;item.id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;name&#x60;: &#x60;contains&#x60;
func (r ApiGetCatalogCategoriesRequest) Filter(filter string) ApiGetCatalogCategoriesRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetCatalogCategoriesRequest) PageCursor(pageCursor string) ApiGetCatalogCategoriesRequest {
	r.pageCursor = &pageCursor
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sorting
func (r ApiGetCatalogCategoriesRequest) Sort(sort string) ApiGetCatalogCategoriesRequest {
	r.sort = &sort
	return r
}

func (r ApiGetCatalogCategoriesRequest) Execute() (*GetCatalogCategoryResponseCollection, *http.Response, error) {
	return r.ApiService.GetCatalogCategoriesExecute(r)
}

/*
GetCatalogCategories Get Catalog Categories

Get all catalog categories in an account.

Catalog categories can be sorted by the following fields, in ascending and descending order:
`created`

Currently, the only supported integration type is `$custom`, and the only supported catalog type is `$default`.

Returns a maximum of 100 categories per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCatalogCategoriesRequest
*/
func (a *CatalogsAPIService) GetCatalogCategories(ctx context.Context) ApiGetCatalogCategoriesRequest {
	return ApiGetCatalogCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogCategoryResponseCollection
func (a *CatalogsAPIService) GetCatalogCategoriesExecute(r ApiGetCatalogCategoriesRequest) (*GetCatalogCategoryResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogCategoryResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCatalogCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-categories/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-category]", r.fieldsCatalogCategory, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogCategoryRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	fieldsCatalogCategory *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCatalogCategoryRequest) Revision(revision string) ApiGetCatalogCategoryRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogCategoryRequest) FieldsCatalogCategory(fieldsCatalogCategory []string) ApiGetCatalogCategoryRequest {
	r.fieldsCatalogCategory = &fieldsCatalogCategory
	return r
}

func (r ApiGetCatalogCategoryRequest) Execute() (*GetCatalogCategoryResponse, *http.Response, error) {
	return r.ApiService.GetCatalogCategoryExecute(r)
}

/*
GetCatalogCategory Get Catalog Category

Get a catalog category with the given category ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The catalog category ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
 @return ApiGetCatalogCategoryRequest
*/
func (a *CatalogsAPIService) GetCatalogCategory(ctx context.Context, id string) ApiGetCatalogCategoryRequest {
	return ApiGetCatalogCategoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetCatalogCategoryResponse
func (a *CatalogsAPIService) GetCatalogCategoryExecute(r ApiGetCatalogCategoryRequest) (*GetCatalogCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCatalogCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-categories/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-category]", r.fieldsCatalogCategory, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogCategoryItemsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	fieldsCatalogItem *[]string
	fieldsCatalogVariant *[]string
	filter *string
	include *[]string
	pageCursor *string
	sort *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCatalogCategoryItemsRequest) Revision(revision string) ApiGetCatalogCategoryItemsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogCategoryItemsRequest) FieldsCatalogItem(fieldsCatalogItem []string) ApiGetCatalogCategoryItemsRequest {
	r.fieldsCatalogItem = &fieldsCatalogItem
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogCategoryItemsRequest) FieldsCatalogVariant(fieldsCatalogVariant []string) ApiGetCatalogCategoryItemsRequest {
	r.fieldsCatalogVariant = &fieldsCatalogVariant
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;ids&#x60;: &#x60;any&#x60;&lt;br&gt;&#x60;category.id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;title&#x60;: &#x60;contains&#x60;&lt;br&gt;&#x60;published&#x60;: &#x60;equals&#x60;
func (r ApiGetCatalogCategoryItemsRequest) Filter(filter string) ApiGetCatalogCategoryItemsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#relationships
func (r ApiGetCatalogCategoryItemsRequest) Include(include []string) ApiGetCatalogCategoryItemsRequest {
	r.include = &include
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetCatalogCategoryItemsRequest) PageCursor(pageCursor string) ApiGetCatalogCategoryItemsRequest {
	r.pageCursor = &pageCursor
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sorting
func (r ApiGetCatalogCategoryItemsRequest) Sort(sort string) ApiGetCatalogCategoryItemsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetCatalogCategoryItemsRequest) Execute() (*GetCatalogItemResponseCollectionCompoundDocument, *http.Response, error) {
	return r.ApiService.GetCatalogCategoryItemsExecute(r)
}

/*
GetCatalogCategoryItems Get Catalog Category Items

Get all items in a category with the given category ID.

Items can be sorted by the following fields, in ascending and descending order:
`created`

Returns a maximum of 100 items per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiGetCatalogCategoryItemsRequest
*/
func (a *CatalogsAPIService) GetCatalogCategoryItems(ctx context.Context, id string) ApiGetCatalogCategoryItemsRequest {
	return ApiGetCatalogCategoryItemsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetCatalogItemResponseCollectionCompoundDocument
func (a *CatalogsAPIService) GetCatalogCategoryItemsExecute(r ApiGetCatalogCategoryItemsRequest) (*GetCatalogItemResponseCollectionCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogItemResponseCollectionCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCatalogCategoryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-categories/{id}/items/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogItem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-item]", r.fieldsCatalogItem, "csv")
	}
	if r.fieldsCatalogVariant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant]", r.fieldsCatalogVariant, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogCategoryRelationshipsItemsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	pageCursor *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCatalogCategoryRelationshipsItemsRequest) Revision(revision string) ApiGetCatalogCategoryRelationshipsItemsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetCatalogCategoryRelationshipsItemsRequest) PageCursor(pageCursor string) ApiGetCatalogCategoryRelationshipsItemsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetCatalogCategoryRelationshipsItemsRequest) Execute() (*GetCatalogCategoryItemListResponseCollection, *http.Response, error) {
	return r.ApiService.GetCatalogCategoryRelationshipsItemsExecute(r)
}

/*
GetCatalogCategoryRelationshipsItems Get Catalog Category Relationships Items

Get all items in the given category ID.

Returns a maximum of 100 items per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiGetCatalogCategoryRelationshipsItemsRequest
*/
func (a *CatalogsAPIService) GetCatalogCategoryRelationshipsItems(ctx context.Context, id string) ApiGetCatalogCategoryRelationshipsItemsRequest {
	return ApiGetCatalogCategoryRelationshipsItemsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetCatalogCategoryItemListResponseCollection
func (a *CatalogsAPIService) GetCatalogCategoryRelationshipsItemsExecute(r ApiGetCatalogCategoryRelationshipsItemsRequest) (*GetCatalogCategoryItemListResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogCategoryItemListResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCatalogCategoryRelationshipsItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-categories/{id}/relationships/items/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogItemRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	fieldsCatalogItem *[]string
	fieldsCatalogVariant *[]string
	include *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCatalogItemRequest) Revision(revision string) ApiGetCatalogItemRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogItemRequest) FieldsCatalogItem(fieldsCatalogItem []string) ApiGetCatalogItemRequest {
	r.fieldsCatalogItem = &fieldsCatalogItem
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogItemRequest) FieldsCatalogVariant(fieldsCatalogVariant []string) ApiGetCatalogItemRequest {
	r.fieldsCatalogVariant = &fieldsCatalogVariant
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#relationships
func (r ApiGetCatalogItemRequest) Include(include []string) ApiGetCatalogItemRequest {
	r.include = &include
	return r
}

func (r ApiGetCatalogItemRequest) Execute() (*GetCatalogItemResponseCompoundDocument, *http.Response, error) {
	return r.ApiService.GetCatalogItemExecute(r)
}

/*
GetCatalogItem Get Catalog Item

Get a specific catalog item with the given item ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The catalog item ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
 @return ApiGetCatalogItemRequest
*/
func (a *CatalogsAPIService) GetCatalogItem(ctx context.Context, id string) ApiGetCatalogItemRequest {
	return ApiGetCatalogItemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetCatalogItemResponseCompoundDocument
func (a *CatalogsAPIService) GetCatalogItemExecute(r ApiGetCatalogItemRequest) (*GetCatalogItemResponseCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogItemResponseCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCatalogItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogItem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-item]", r.fieldsCatalogItem, "csv")
	}
	if r.fieldsCatalogVariant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant]", r.fieldsCatalogVariant, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogItemCategoriesRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	fieldsCatalogCategory *[]string
	filter *string
	pageCursor *string
	sort *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCatalogItemCategoriesRequest) Revision(revision string) ApiGetCatalogItemCategoriesRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogItemCategoriesRequest) FieldsCatalogCategory(fieldsCatalogCategory []string) ApiGetCatalogItemCategoriesRequest {
	r.fieldsCatalogCategory = &fieldsCatalogCategory
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;ids&#x60;: &#x60;any&#x60;&lt;br&gt;&#x60;item.id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;name&#x60;: &#x60;contains&#x60;
func (r ApiGetCatalogItemCategoriesRequest) Filter(filter string) ApiGetCatalogItemCategoriesRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetCatalogItemCategoriesRequest) PageCursor(pageCursor string) ApiGetCatalogItemCategoriesRequest {
	r.pageCursor = &pageCursor
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sorting
func (r ApiGetCatalogItemCategoriesRequest) Sort(sort string) ApiGetCatalogItemCategoriesRequest {
	r.sort = &sort
	return r
}

func (r ApiGetCatalogItemCategoriesRequest) Execute() (*GetCatalogCategoryResponseCollection, *http.Response, error) {
	return r.ApiService.GetCatalogItemCategoriesExecute(r)
}

/*
GetCatalogItemCategories Get Catalog Item Categories

Get all catalog categories that an item with the given item ID is in.

Catalog categories can be sorted by the following fields, in ascending and descending order:
`created`

Returns a maximum of 100 categories per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiGetCatalogItemCategoriesRequest
*/
func (a *CatalogsAPIService) GetCatalogItemCategories(ctx context.Context, id string) ApiGetCatalogItemCategoriesRequest {
	return ApiGetCatalogItemCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetCatalogCategoryResponseCollection
func (a *CatalogsAPIService) GetCatalogItemCategoriesExecute(r ApiGetCatalogItemCategoriesRequest) (*GetCatalogCategoryResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogCategoryResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCatalogItemCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-items/{id}/categories/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-category]", r.fieldsCatalogCategory, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogItemRelationshipsCategoriesRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	pageCursor *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCatalogItemRelationshipsCategoriesRequest) Revision(revision string) ApiGetCatalogItemRelationshipsCategoriesRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetCatalogItemRelationshipsCategoriesRequest) PageCursor(pageCursor string) ApiGetCatalogItemRelationshipsCategoriesRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetCatalogItemRelationshipsCategoriesRequest) Execute() (*GetCatalogItemCategoryListResponseCollection, *http.Response, error) {
	return r.ApiService.GetCatalogItemRelationshipsCategoriesExecute(r)
}

/*
GetCatalogItemRelationshipsCategories Get Catalog Item Relationships Categories

Get all catalog categories that a particular item is in.

Returns a maximum of 100 categories per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiGetCatalogItemRelationshipsCategoriesRequest
*/
func (a *CatalogsAPIService) GetCatalogItemRelationshipsCategories(ctx context.Context, id string) ApiGetCatalogItemRelationshipsCategoriesRequest {
	return ApiGetCatalogItemRelationshipsCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetCatalogItemCategoryListResponseCollection
func (a *CatalogsAPIService) GetCatalogItemRelationshipsCategoriesExecute(r ApiGetCatalogItemRelationshipsCategoriesRequest) (*GetCatalogItemCategoryListResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogItemCategoryListResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCatalogItemRelationshipsCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-items/{id}/relationships/categories/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogItemVariantsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	fieldsCatalogVariant *[]string
	filter *string
	pageCursor *string
	sort *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCatalogItemVariantsRequest) Revision(revision string) ApiGetCatalogItemVariantsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogItemVariantsRequest) FieldsCatalogVariant(fieldsCatalogVariant []string) ApiGetCatalogItemVariantsRequest {
	r.fieldsCatalogVariant = &fieldsCatalogVariant
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;ids&#x60;: &#x60;any&#x60;&lt;br&gt;&#x60;item.id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;sku&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;title&#x60;: &#x60;contains&#x60;&lt;br&gt;&#x60;published&#x60;: &#x60;equals&#x60;
func (r ApiGetCatalogItemVariantsRequest) Filter(filter string) ApiGetCatalogItemVariantsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetCatalogItemVariantsRequest) PageCursor(pageCursor string) ApiGetCatalogItemVariantsRequest {
	r.pageCursor = &pageCursor
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sorting
func (r ApiGetCatalogItemVariantsRequest) Sort(sort string) ApiGetCatalogItemVariantsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetCatalogItemVariantsRequest) Execute() (*GetCatalogVariantResponseCollection, *http.Response, error) {
	return r.ApiService.GetCatalogItemVariantsExecute(r)
}

/*
GetCatalogItemVariants Get Catalog Item Variants

Get all variants related to the given item ID.

Variants can be sorted by the following fields, in ascending and descending order:
`created`

Returns a maximum of 100 variants per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiGetCatalogItemVariantsRequest
*/
func (a *CatalogsAPIService) GetCatalogItemVariants(ctx context.Context, id string) ApiGetCatalogItemVariantsRequest {
	return ApiGetCatalogItemVariantsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetCatalogVariantResponseCollection
func (a *CatalogsAPIService) GetCatalogItemVariantsExecute(r ApiGetCatalogItemVariantsRequest) (*GetCatalogVariantResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogVariantResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCatalogItemVariants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-items/{id}/variants/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogVariant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant]", r.fieldsCatalogVariant, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogItemsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogItem *[]string
	fieldsCatalogVariant *[]string
	filter *string
	include *[]string
	pageCursor *string
	sort *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCatalogItemsRequest) Revision(revision string) ApiGetCatalogItemsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogItemsRequest) FieldsCatalogItem(fieldsCatalogItem []string) ApiGetCatalogItemsRequest {
	r.fieldsCatalogItem = &fieldsCatalogItem
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogItemsRequest) FieldsCatalogVariant(fieldsCatalogVariant []string) ApiGetCatalogItemsRequest {
	r.fieldsCatalogVariant = &fieldsCatalogVariant
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;ids&#x60;: &#x60;any&#x60;&lt;br&gt;&#x60;category.id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;title&#x60;: &#x60;contains&#x60;&lt;br&gt;&#x60;published&#x60;: &#x60;equals&#x60;
func (r ApiGetCatalogItemsRequest) Filter(filter string) ApiGetCatalogItemsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#relationships
func (r ApiGetCatalogItemsRequest) Include(include []string) ApiGetCatalogItemsRequest {
	r.include = &include
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetCatalogItemsRequest) PageCursor(pageCursor string) ApiGetCatalogItemsRequest {
	r.pageCursor = &pageCursor
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sorting
func (r ApiGetCatalogItemsRequest) Sort(sort string) ApiGetCatalogItemsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetCatalogItemsRequest) Execute() (*GetCatalogItemResponseCollectionCompoundDocument, *http.Response, error) {
	return r.ApiService.GetCatalogItemsExecute(r)
}

/*
GetCatalogItems Get Catalog Items

Get all catalog items in an account.

Catalog items can be sorted by the following fields, in ascending and descending order:
`created`

Currently, the only supported integration type is `$custom`, and the only supported catalog type is `$default`.

Returns a maximum of 100 items per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCatalogItemsRequest
*/
func (a *CatalogsAPIService) GetCatalogItems(ctx context.Context) ApiGetCatalogItemsRequest {
	return ApiGetCatalogItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogItemResponseCollectionCompoundDocument
func (a *CatalogsAPIService) GetCatalogItemsExecute(r ApiGetCatalogItemsRequest) (*GetCatalogItemResponseCollectionCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogItemResponseCollectionCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCatalogItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-items/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogItem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-item]", r.fieldsCatalogItem, "csv")
	}
	if r.fieldsCatalogVariant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant]", r.fieldsCatalogVariant, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogVariantRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	fieldsCatalogVariant *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCatalogVariantRequest) Revision(revision string) ApiGetCatalogVariantRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogVariantRequest) FieldsCatalogVariant(fieldsCatalogVariant []string) ApiGetCatalogVariantRequest {
	r.fieldsCatalogVariant = &fieldsCatalogVariant
	return r
}

func (r ApiGetCatalogVariantRequest) Execute() (*GetCatalogVariantResponse, *http.Response, error) {
	return r.ApiService.GetCatalogVariantExecute(r)
}

/*
GetCatalogVariant Get Catalog Variant

Get a catalog item variant with the given variant ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The catalog variant ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
 @return ApiGetCatalogVariantRequest
*/
func (a *CatalogsAPIService) GetCatalogVariant(ctx context.Context, id string) ApiGetCatalogVariantRequest {
	return ApiGetCatalogVariantRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetCatalogVariantResponse
func (a *CatalogsAPIService) GetCatalogVariantExecute(r ApiGetCatalogVariantRequest) (*GetCatalogVariantResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogVariantResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCatalogVariant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variants/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogVariant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant]", r.fieldsCatalogVariant, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCatalogVariantsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogVariant *[]string
	filter *string
	pageCursor *string
	sort *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCatalogVariantsRequest) Revision(revision string) ApiGetCatalogVariantsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCatalogVariantsRequest) FieldsCatalogVariant(fieldsCatalogVariant []string) ApiGetCatalogVariantsRequest {
	r.fieldsCatalogVariant = &fieldsCatalogVariant
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;ids&#x60;: &#x60;any&#x60;&lt;br&gt;&#x60;item.id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;sku&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;title&#x60;: &#x60;contains&#x60;&lt;br&gt;&#x60;published&#x60;: &#x60;equals&#x60;
func (r ApiGetCatalogVariantsRequest) Filter(filter string) ApiGetCatalogVariantsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetCatalogVariantsRequest) PageCursor(pageCursor string) ApiGetCatalogVariantsRequest {
	r.pageCursor = &pageCursor
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sorting
func (r ApiGetCatalogVariantsRequest) Sort(sort string) ApiGetCatalogVariantsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetCatalogVariantsRequest) Execute() (*GetCatalogVariantResponseCollection, *http.Response, error) {
	return r.ApiService.GetCatalogVariantsExecute(r)
}

/*
GetCatalogVariants Get Catalog Variants

Get all variants in an account.

Variants can be sorted by the following fields, in ascending and descending order:
`created`

Currently, the only supported integration type is `$custom`, and the only supported catalog type is `$default`.

Returns a maximum of 100 variants per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCatalogVariantsRequest
*/
func (a *CatalogsAPIService) GetCatalogVariants(ctx context.Context) ApiGetCatalogVariantsRequest {
	return ApiGetCatalogVariantsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogVariantResponseCollection
func (a *CatalogsAPIService) GetCatalogVariantsExecute(r ApiGetCatalogVariantsRequest) (*GetCatalogVariantResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogVariantResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCatalogVariants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variants/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogVariant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant]", r.fieldsCatalogVariant, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreateCategoriesJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	jobId string
	revision *string
	fieldsCatalogCategoryBulkCreateJob *[]string
	fieldsCatalogCategory *[]string
	include *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCreateCategoriesJobRequest) Revision(revision string) ApiGetCreateCategoriesJobRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCreateCategoriesJobRequest) FieldsCatalogCategoryBulkCreateJob(fieldsCatalogCategoryBulkCreateJob []string) ApiGetCreateCategoriesJobRequest {
	r.fieldsCatalogCategoryBulkCreateJob = &fieldsCatalogCategoryBulkCreateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCreateCategoriesJobRequest) FieldsCatalogCategory(fieldsCatalogCategory []string) ApiGetCreateCategoriesJobRequest {
	r.fieldsCatalogCategory = &fieldsCatalogCategory
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#relationships
func (r ApiGetCreateCategoriesJobRequest) Include(include []string) ApiGetCreateCategoriesJobRequest {
	r.include = &include
	return r
}

func (r ApiGetCreateCategoriesJobRequest) Execute() (*GetCatalogCategoryCreateJobResponseCompoundDocument, *http.Response, error) {
	return r.ApiService.GetCreateCategoriesJobExecute(r)
}

/*
GetCreateCategoriesJob Get Create Categories Job

Get a catalog category bulk create job with the given job ID.

An `include` parameter can be provided to get the following related resource data: `categories`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId ID of the job to retrieve.
 @return ApiGetCreateCategoriesJobRequest
*/
func (a *CatalogsAPIService) GetCreateCategoriesJob(ctx context.Context, jobId string) ApiGetCreateCategoriesJobRequest {
	return ApiGetCreateCategoriesJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return GetCatalogCategoryCreateJobResponseCompoundDocument
func (a *CatalogsAPIService) GetCreateCategoriesJobExecute(r ApiGetCreateCategoriesJobRequest) (*GetCatalogCategoryCreateJobResponseCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogCategoryCreateJobResponseCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCreateCategoriesJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-category-bulk-create-jobs/{job_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogCategoryBulkCreateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-category-bulk-create-job]", r.fieldsCatalogCategoryBulkCreateJob, "csv")
	}
	if r.fieldsCatalogCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-category]", r.fieldsCatalogCategory, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreateCategoriesJobsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogCategoryBulkCreateJob *[]string
	filter *string
	pageCursor *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCreateCategoriesJobsRequest) Revision(revision string) ApiGetCreateCategoriesJobsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCreateCategoriesJobsRequest) FieldsCatalogCategoryBulkCreateJob(fieldsCatalogCategoryBulkCreateJob []string) ApiGetCreateCategoriesJobsRequest {
	r.fieldsCatalogCategoryBulkCreateJob = &fieldsCatalogCategoryBulkCreateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;equals&#x60;
func (r ApiGetCreateCategoriesJobsRequest) Filter(filter string) ApiGetCreateCategoriesJobsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetCreateCategoriesJobsRequest) PageCursor(pageCursor string) ApiGetCreateCategoriesJobsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetCreateCategoriesJobsRequest) Execute() (*GetCatalogCategoryCreateJobResponseCollectionCompoundDocument, *http.Response, error) {
	return r.ApiService.GetCreateCategoriesJobsExecute(r)
}

/*
GetCreateCategoriesJobs Get Create Categories Jobs

Get all catalog category bulk create jobs.

Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCreateCategoriesJobsRequest
*/
func (a *CatalogsAPIService) GetCreateCategoriesJobs(ctx context.Context) ApiGetCreateCategoriesJobsRequest {
	return ApiGetCreateCategoriesJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogCategoryCreateJobResponseCollectionCompoundDocument
func (a *CatalogsAPIService) GetCreateCategoriesJobsExecute(r ApiGetCreateCategoriesJobsRequest) (*GetCatalogCategoryCreateJobResponseCollectionCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogCategoryCreateJobResponseCollectionCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCreateCategoriesJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-category-bulk-create-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogCategoryBulkCreateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-category-bulk-create-job]", r.fieldsCatalogCategoryBulkCreateJob, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreateItemsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	jobId string
	revision *string
	fieldsCatalogItemBulkCreateJob *[]string
	fieldsCatalogItem *[]string
	include *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCreateItemsJobRequest) Revision(revision string) ApiGetCreateItemsJobRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCreateItemsJobRequest) FieldsCatalogItemBulkCreateJob(fieldsCatalogItemBulkCreateJob []string) ApiGetCreateItemsJobRequest {
	r.fieldsCatalogItemBulkCreateJob = &fieldsCatalogItemBulkCreateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCreateItemsJobRequest) FieldsCatalogItem(fieldsCatalogItem []string) ApiGetCreateItemsJobRequest {
	r.fieldsCatalogItem = &fieldsCatalogItem
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#relationships
func (r ApiGetCreateItemsJobRequest) Include(include []string) ApiGetCreateItemsJobRequest {
	r.include = &include
	return r
}

func (r ApiGetCreateItemsJobRequest) Execute() (*GetCatalogItemCreateJobResponseCompoundDocument, *http.Response, error) {
	return r.ApiService.GetCreateItemsJobExecute(r)
}

/*
GetCreateItemsJob Get Create Items Job

Get a catalog item bulk create job with the given job ID.

An `include` parameter can be provided to get the following related resource data: `items`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId ID of the job to retrieve.
 @return ApiGetCreateItemsJobRequest
*/
func (a *CatalogsAPIService) GetCreateItemsJob(ctx context.Context, jobId string) ApiGetCreateItemsJobRequest {
	return ApiGetCreateItemsJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return GetCatalogItemCreateJobResponseCompoundDocument
func (a *CatalogsAPIService) GetCreateItemsJobExecute(r ApiGetCreateItemsJobRequest) (*GetCatalogItemCreateJobResponseCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogItemCreateJobResponseCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCreateItemsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-item-bulk-create-jobs/{job_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogItemBulkCreateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-item-bulk-create-job]", r.fieldsCatalogItemBulkCreateJob, "csv")
	}
	if r.fieldsCatalogItem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-item]", r.fieldsCatalogItem, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreateItemsJobsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogItemBulkCreateJob *[]string
	filter *string
	pageCursor *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCreateItemsJobsRequest) Revision(revision string) ApiGetCreateItemsJobsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCreateItemsJobsRequest) FieldsCatalogItemBulkCreateJob(fieldsCatalogItemBulkCreateJob []string) ApiGetCreateItemsJobsRequest {
	r.fieldsCatalogItemBulkCreateJob = &fieldsCatalogItemBulkCreateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;equals&#x60;
func (r ApiGetCreateItemsJobsRequest) Filter(filter string) ApiGetCreateItemsJobsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetCreateItemsJobsRequest) PageCursor(pageCursor string) ApiGetCreateItemsJobsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetCreateItemsJobsRequest) Execute() (*GetCatalogItemCreateJobResponseCollectionCompoundDocument, *http.Response, error) {
	return r.ApiService.GetCreateItemsJobsExecute(r)
}

/*
GetCreateItemsJobs Get Create Items Jobs

Get all catalog item bulk create jobs.

Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCreateItemsJobsRequest
*/
func (a *CatalogsAPIService) GetCreateItemsJobs(ctx context.Context) ApiGetCreateItemsJobsRequest {
	return ApiGetCreateItemsJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogItemCreateJobResponseCollectionCompoundDocument
func (a *CatalogsAPIService) GetCreateItemsJobsExecute(r ApiGetCreateItemsJobsRequest) (*GetCatalogItemCreateJobResponseCollectionCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogItemCreateJobResponseCollectionCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCreateItemsJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-item-bulk-create-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogItemBulkCreateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-item-bulk-create-job]", r.fieldsCatalogItemBulkCreateJob, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreateVariantsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	jobId string
	revision *string
	fieldsCatalogVariantBulkCreateJob *[]string
	fieldsCatalogVariant *[]string
	include *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCreateVariantsJobRequest) Revision(revision string) ApiGetCreateVariantsJobRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCreateVariantsJobRequest) FieldsCatalogVariantBulkCreateJob(fieldsCatalogVariantBulkCreateJob []string) ApiGetCreateVariantsJobRequest {
	r.fieldsCatalogVariantBulkCreateJob = &fieldsCatalogVariantBulkCreateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCreateVariantsJobRequest) FieldsCatalogVariant(fieldsCatalogVariant []string) ApiGetCreateVariantsJobRequest {
	r.fieldsCatalogVariant = &fieldsCatalogVariant
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#relationships
func (r ApiGetCreateVariantsJobRequest) Include(include []string) ApiGetCreateVariantsJobRequest {
	r.include = &include
	return r
}

func (r ApiGetCreateVariantsJobRequest) Execute() (*GetCatalogVariantCreateJobResponseCompoundDocument, *http.Response, error) {
	return r.ApiService.GetCreateVariantsJobExecute(r)
}

/*
GetCreateVariantsJob Get Create Variants Job

Get a catalog variant bulk create job with the given job ID.

An `include` parameter can be provided to get the following related resource data: `variants`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId ID of the job to retrieve.
 @return ApiGetCreateVariantsJobRequest
*/
func (a *CatalogsAPIService) GetCreateVariantsJob(ctx context.Context, jobId string) ApiGetCreateVariantsJobRequest {
	return ApiGetCreateVariantsJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return GetCatalogVariantCreateJobResponseCompoundDocument
func (a *CatalogsAPIService) GetCreateVariantsJobExecute(r ApiGetCreateVariantsJobRequest) (*GetCatalogVariantCreateJobResponseCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogVariantCreateJobResponseCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCreateVariantsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variant-bulk-create-jobs/{job_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogVariantBulkCreateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant-bulk-create-job]", r.fieldsCatalogVariantBulkCreateJob, "csv")
	}
	if r.fieldsCatalogVariant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant]", r.fieldsCatalogVariant, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreateVariantsJobsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogVariantBulkCreateJob *[]string
	filter *string
	pageCursor *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetCreateVariantsJobsRequest) Revision(revision string) ApiGetCreateVariantsJobsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetCreateVariantsJobsRequest) FieldsCatalogVariantBulkCreateJob(fieldsCatalogVariantBulkCreateJob []string) ApiGetCreateVariantsJobsRequest {
	r.fieldsCatalogVariantBulkCreateJob = &fieldsCatalogVariantBulkCreateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;equals&#x60;
func (r ApiGetCreateVariantsJobsRequest) Filter(filter string) ApiGetCreateVariantsJobsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetCreateVariantsJobsRequest) PageCursor(pageCursor string) ApiGetCreateVariantsJobsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetCreateVariantsJobsRequest) Execute() (*GetCatalogVariantCreateJobResponseCollectionCompoundDocument, *http.Response, error) {
	return r.ApiService.GetCreateVariantsJobsExecute(r)
}

/*
GetCreateVariantsJobs Get Create Variants Jobs

Get all catalog variant bulk create jobs.

Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCreateVariantsJobsRequest
*/
func (a *CatalogsAPIService) GetCreateVariantsJobs(ctx context.Context) ApiGetCreateVariantsJobsRequest {
	return ApiGetCreateVariantsJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogVariantCreateJobResponseCollectionCompoundDocument
func (a *CatalogsAPIService) GetCreateVariantsJobsExecute(r ApiGetCreateVariantsJobsRequest) (*GetCatalogVariantCreateJobResponseCollectionCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogVariantCreateJobResponseCollectionCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetCreateVariantsJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variant-bulk-create-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogVariantBulkCreateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant-bulk-create-job]", r.fieldsCatalogVariantBulkCreateJob, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeleteCategoriesJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	jobId string
	revision *string
	fieldsCatalogCategoryBulkDeleteJob *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetDeleteCategoriesJobRequest) Revision(revision string) ApiGetDeleteCategoriesJobRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetDeleteCategoriesJobRequest) FieldsCatalogCategoryBulkDeleteJob(fieldsCatalogCategoryBulkDeleteJob []string) ApiGetDeleteCategoriesJobRequest {
	r.fieldsCatalogCategoryBulkDeleteJob = &fieldsCatalogCategoryBulkDeleteJob
	return r
}

func (r ApiGetDeleteCategoriesJobRequest) Execute() (*GetCatalogCategoryDeleteJobResponse, *http.Response, error) {
	return r.ApiService.GetDeleteCategoriesJobExecute(r)
}

/*
GetDeleteCategoriesJob Get Delete Categories Job

Get a catalog category bulk delete job with the given job ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId ID of the job to retrieve.
 @return ApiGetDeleteCategoriesJobRequest
*/
func (a *CatalogsAPIService) GetDeleteCategoriesJob(ctx context.Context, jobId string) ApiGetDeleteCategoriesJobRequest {
	return ApiGetDeleteCategoriesJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return GetCatalogCategoryDeleteJobResponse
func (a *CatalogsAPIService) GetDeleteCategoriesJobExecute(r ApiGetDeleteCategoriesJobRequest) (*GetCatalogCategoryDeleteJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogCategoryDeleteJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetDeleteCategoriesJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-category-bulk-delete-jobs/{job_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogCategoryBulkDeleteJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-category-bulk-delete-job]", r.fieldsCatalogCategoryBulkDeleteJob, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeleteCategoriesJobsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogCategoryBulkDeleteJob *[]string
	filter *string
	pageCursor *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetDeleteCategoriesJobsRequest) Revision(revision string) ApiGetDeleteCategoriesJobsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetDeleteCategoriesJobsRequest) FieldsCatalogCategoryBulkDeleteJob(fieldsCatalogCategoryBulkDeleteJob []string) ApiGetDeleteCategoriesJobsRequest {
	r.fieldsCatalogCategoryBulkDeleteJob = &fieldsCatalogCategoryBulkDeleteJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;equals&#x60;
func (r ApiGetDeleteCategoriesJobsRequest) Filter(filter string) ApiGetDeleteCategoriesJobsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetDeleteCategoriesJobsRequest) PageCursor(pageCursor string) ApiGetDeleteCategoriesJobsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetDeleteCategoriesJobsRequest) Execute() (*GetCatalogCategoryDeleteJobResponseCollection, *http.Response, error) {
	return r.ApiService.GetDeleteCategoriesJobsExecute(r)
}

/*
GetDeleteCategoriesJobs Get Delete Categories Jobs

Get all catalog category bulk delete jobs.

Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDeleteCategoriesJobsRequest
*/
func (a *CatalogsAPIService) GetDeleteCategoriesJobs(ctx context.Context) ApiGetDeleteCategoriesJobsRequest {
	return ApiGetDeleteCategoriesJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogCategoryDeleteJobResponseCollection
func (a *CatalogsAPIService) GetDeleteCategoriesJobsExecute(r ApiGetDeleteCategoriesJobsRequest) (*GetCatalogCategoryDeleteJobResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogCategoryDeleteJobResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetDeleteCategoriesJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-category-bulk-delete-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogCategoryBulkDeleteJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-category-bulk-delete-job]", r.fieldsCatalogCategoryBulkDeleteJob, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeleteItemsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	jobId string
	revision *string
	fieldsCatalogItemBulkDeleteJob *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetDeleteItemsJobRequest) Revision(revision string) ApiGetDeleteItemsJobRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetDeleteItemsJobRequest) FieldsCatalogItemBulkDeleteJob(fieldsCatalogItemBulkDeleteJob []string) ApiGetDeleteItemsJobRequest {
	r.fieldsCatalogItemBulkDeleteJob = &fieldsCatalogItemBulkDeleteJob
	return r
}

func (r ApiGetDeleteItemsJobRequest) Execute() (*GetCatalogItemDeleteJobResponse, *http.Response, error) {
	return r.ApiService.GetDeleteItemsJobExecute(r)
}

/*
GetDeleteItemsJob Get Delete Items Job

Get a catalog item bulk delete job with the given job ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId ID of the job to retrieve.
 @return ApiGetDeleteItemsJobRequest
*/
func (a *CatalogsAPIService) GetDeleteItemsJob(ctx context.Context, jobId string) ApiGetDeleteItemsJobRequest {
	return ApiGetDeleteItemsJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return GetCatalogItemDeleteJobResponse
func (a *CatalogsAPIService) GetDeleteItemsJobExecute(r ApiGetDeleteItemsJobRequest) (*GetCatalogItemDeleteJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogItemDeleteJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetDeleteItemsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-item-bulk-delete-jobs/{job_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogItemBulkDeleteJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-item-bulk-delete-job]", r.fieldsCatalogItemBulkDeleteJob, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeleteItemsJobsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogItemBulkDeleteJob *[]string
	filter *string
	pageCursor *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetDeleteItemsJobsRequest) Revision(revision string) ApiGetDeleteItemsJobsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetDeleteItemsJobsRequest) FieldsCatalogItemBulkDeleteJob(fieldsCatalogItemBulkDeleteJob []string) ApiGetDeleteItemsJobsRequest {
	r.fieldsCatalogItemBulkDeleteJob = &fieldsCatalogItemBulkDeleteJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;equals&#x60;
func (r ApiGetDeleteItemsJobsRequest) Filter(filter string) ApiGetDeleteItemsJobsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetDeleteItemsJobsRequest) PageCursor(pageCursor string) ApiGetDeleteItemsJobsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetDeleteItemsJobsRequest) Execute() (*GetCatalogItemDeleteJobResponseCollection, *http.Response, error) {
	return r.ApiService.GetDeleteItemsJobsExecute(r)
}

/*
GetDeleteItemsJobs Get Delete Items Jobs

Get all catalog item bulk delete jobs.

Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDeleteItemsJobsRequest
*/
func (a *CatalogsAPIService) GetDeleteItemsJobs(ctx context.Context) ApiGetDeleteItemsJobsRequest {
	return ApiGetDeleteItemsJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogItemDeleteJobResponseCollection
func (a *CatalogsAPIService) GetDeleteItemsJobsExecute(r ApiGetDeleteItemsJobsRequest) (*GetCatalogItemDeleteJobResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogItemDeleteJobResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetDeleteItemsJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-item-bulk-delete-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogItemBulkDeleteJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-item-bulk-delete-job]", r.fieldsCatalogItemBulkDeleteJob, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeleteVariantsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	jobId string
	revision *string
	fieldsCatalogVariantBulkDeleteJob *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetDeleteVariantsJobRequest) Revision(revision string) ApiGetDeleteVariantsJobRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetDeleteVariantsJobRequest) FieldsCatalogVariantBulkDeleteJob(fieldsCatalogVariantBulkDeleteJob []string) ApiGetDeleteVariantsJobRequest {
	r.fieldsCatalogVariantBulkDeleteJob = &fieldsCatalogVariantBulkDeleteJob
	return r
}

func (r ApiGetDeleteVariantsJobRequest) Execute() (*GetCatalogVariantDeleteJobResponse, *http.Response, error) {
	return r.ApiService.GetDeleteVariantsJobExecute(r)
}

/*
GetDeleteVariantsJob Get Delete Variants Job

Get a catalog variant bulk delete job with the given job ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId ID of the job to retrieve.
 @return ApiGetDeleteVariantsJobRequest
*/
func (a *CatalogsAPIService) GetDeleteVariantsJob(ctx context.Context, jobId string) ApiGetDeleteVariantsJobRequest {
	return ApiGetDeleteVariantsJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return GetCatalogVariantDeleteJobResponse
func (a *CatalogsAPIService) GetDeleteVariantsJobExecute(r ApiGetDeleteVariantsJobRequest) (*GetCatalogVariantDeleteJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogVariantDeleteJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetDeleteVariantsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variant-bulk-delete-jobs/{job_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogVariantBulkDeleteJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant-bulk-delete-job]", r.fieldsCatalogVariantBulkDeleteJob, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeleteVariantsJobsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogVariantBulkDeleteJob *[]string
	filter *string
	pageCursor *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetDeleteVariantsJobsRequest) Revision(revision string) ApiGetDeleteVariantsJobsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetDeleteVariantsJobsRequest) FieldsCatalogVariantBulkDeleteJob(fieldsCatalogVariantBulkDeleteJob []string) ApiGetDeleteVariantsJobsRequest {
	r.fieldsCatalogVariantBulkDeleteJob = &fieldsCatalogVariantBulkDeleteJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;equals&#x60;
func (r ApiGetDeleteVariantsJobsRequest) Filter(filter string) ApiGetDeleteVariantsJobsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetDeleteVariantsJobsRequest) PageCursor(pageCursor string) ApiGetDeleteVariantsJobsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetDeleteVariantsJobsRequest) Execute() (*GetCatalogVariantDeleteJobResponseCollection, *http.Response, error) {
	return r.ApiService.GetDeleteVariantsJobsExecute(r)
}

/*
GetDeleteVariantsJobs Get Delete Variants Jobs

Get all catalog variant bulk delete jobs.

Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDeleteVariantsJobsRequest
*/
func (a *CatalogsAPIService) GetDeleteVariantsJobs(ctx context.Context) ApiGetDeleteVariantsJobsRequest {
	return ApiGetDeleteVariantsJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogVariantDeleteJobResponseCollection
func (a *CatalogsAPIService) GetDeleteVariantsJobsExecute(r ApiGetDeleteVariantsJobsRequest) (*GetCatalogVariantDeleteJobResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogVariantDeleteJobResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetDeleteVariantsJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variant-bulk-delete-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogVariantBulkDeleteJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant-bulk-delete-job]", r.fieldsCatalogVariantBulkDeleteJob, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpdateCategoriesJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	jobId string
	revision *string
	fieldsCatalogCategoryBulkUpdateJob *[]string
	fieldsCatalogCategory *[]string
	include *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetUpdateCategoriesJobRequest) Revision(revision string) ApiGetUpdateCategoriesJobRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetUpdateCategoriesJobRequest) FieldsCatalogCategoryBulkUpdateJob(fieldsCatalogCategoryBulkUpdateJob []string) ApiGetUpdateCategoriesJobRequest {
	r.fieldsCatalogCategoryBulkUpdateJob = &fieldsCatalogCategoryBulkUpdateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetUpdateCategoriesJobRequest) FieldsCatalogCategory(fieldsCatalogCategory []string) ApiGetUpdateCategoriesJobRequest {
	r.fieldsCatalogCategory = &fieldsCatalogCategory
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#relationships
func (r ApiGetUpdateCategoriesJobRequest) Include(include []string) ApiGetUpdateCategoriesJobRequest {
	r.include = &include
	return r
}

func (r ApiGetUpdateCategoriesJobRequest) Execute() (*GetCatalogCategoryUpdateJobResponseCompoundDocument, *http.Response, error) {
	return r.ApiService.GetUpdateCategoriesJobExecute(r)
}

/*
GetUpdateCategoriesJob Get Update Categories Job

Get a catalog category bulk update job with the given job ID.

An `include` parameter can be provided to get the following related resource data: `categories`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId ID of the job to retrieve.
 @return ApiGetUpdateCategoriesJobRequest
*/
func (a *CatalogsAPIService) GetUpdateCategoriesJob(ctx context.Context, jobId string) ApiGetUpdateCategoriesJobRequest {
	return ApiGetUpdateCategoriesJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return GetCatalogCategoryUpdateJobResponseCompoundDocument
func (a *CatalogsAPIService) GetUpdateCategoriesJobExecute(r ApiGetUpdateCategoriesJobRequest) (*GetCatalogCategoryUpdateJobResponseCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogCategoryUpdateJobResponseCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetUpdateCategoriesJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-category-bulk-update-jobs/{job_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogCategoryBulkUpdateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-category-bulk-update-job]", r.fieldsCatalogCategoryBulkUpdateJob, "csv")
	}
	if r.fieldsCatalogCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-category]", r.fieldsCatalogCategory, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpdateCategoriesJobsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogCategoryBulkUpdateJob *[]string
	filter *string
	pageCursor *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetUpdateCategoriesJobsRequest) Revision(revision string) ApiGetUpdateCategoriesJobsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetUpdateCategoriesJobsRequest) FieldsCatalogCategoryBulkUpdateJob(fieldsCatalogCategoryBulkUpdateJob []string) ApiGetUpdateCategoriesJobsRequest {
	r.fieldsCatalogCategoryBulkUpdateJob = &fieldsCatalogCategoryBulkUpdateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;equals&#x60;
func (r ApiGetUpdateCategoriesJobsRequest) Filter(filter string) ApiGetUpdateCategoriesJobsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetUpdateCategoriesJobsRequest) PageCursor(pageCursor string) ApiGetUpdateCategoriesJobsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetUpdateCategoriesJobsRequest) Execute() (*GetCatalogCategoryUpdateJobResponseCollectionCompoundDocument, *http.Response, error) {
	return r.ApiService.GetUpdateCategoriesJobsExecute(r)
}

/*
GetUpdateCategoriesJobs Get Update Categories Jobs

Get all catalog category bulk update jobs.

Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUpdateCategoriesJobsRequest
*/
func (a *CatalogsAPIService) GetUpdateCategoriesJobs(ctx context.Context) ApiGetUpdateCategoriesJobsRequest {
	return ApiGetUpdateCategoriesJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogCategoryUpdateJobResponseCollectionCompoundDocument
func (a *CatalogsAPIService) GetUpdateCategoriesJobsExecute(r ApiGetUpdateCategoriesJobsRequest) (*GetCatalogCategoryUpdateJobResponseCollectionCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogCategoryUpdateJobResponseCollectionCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetUpdateCategoriesJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-category-bulk-update-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogCategoryBulkUpdateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-category-bulk-update-job]", r.fieldsCatalogCategoryBulkUpdateJob, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpdateItemsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	jobId string
	revision *string
	fieldsCatalogItemBulkUpdateJob *[]string
	fieldsCatalogItem *[]string
	include *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetUpdateItemsJobRequest) Revision(revision string) ApiGetUpdateItemsJobRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetUpdateItemsJobRequest) FieldsCatalogItemBulkUpdateJob(fieldsCatalogItemBulkUpdateJob []string) ApiGetUpdateItemsJobRequest {
	r.fieldsCatalogItemBulkUpdateJob = &fieldsCatalogItemBulkUpdateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetUpdateItemsJobRequest) FieldsCatalogItem(fieldsCatalogItem []string) ApiGetUpdateItemsJobRequest {
	r.fieldsCatalogItem = &fieldsCatalogItem
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#relationships
func (r ApiGetUpdateItemsJobRequest) Include(include []string) ApiGetUpdateItemsJobRequest {
	r.include = &include
	return r
}

func (r ApiGetUpdateItemsJobRequest) Execute() (*GetCatalogItemUpdateJobResponseCompoundDocument, *http.Response, error) {
	return r.ApiService.GetUpdateItemsJobExecute(r)
}

/*
GetUpdateItemsJob Get Update Items Job

Get a catalog item bulk update job with the given job ID.

An `include` parameter can be provided to get the following related resource data: `items`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId ID of the job to retrieve.
 @return ApiGetUpdateItemsJobRequest
*/
func (a *CatalogsAPIService) GetUpdateItemsJob(ctx context.Context, jobId string) ApiGetUpdateItemsJobRequest {
	return ApiGetUpdateItemsJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return GetCatalogItemUpdateJobResponseCompoundDocument
func (a *CatalogsAPIService) GetUpdateItemsJobExecute(r ApiGetUpdateItemsJobRequest) (*GetCatalogItemUpdateJobResponseCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogItemUpdateJobResponseCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetUpdateItemsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-item-bulk-update-jobs/{job_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogItemBulkUpdateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-item-bulk-update-job]", r.fieldsCatalogItemBulkUpdateJob, "csv")
	}
	if r.fieldsCatalogItem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-item]", r.fieldsCatalogItem, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpdateItemsJobsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogItemBulkUpdateJob *[]string
	filter *string
	pageCursor *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetUpdateItemsJobsRequest) Revision(revision string) ApiGetUpdateItemsJobsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetUpdateItemsJobsRequest) FieldsCatalogItemBulkUpdateJob(fieldsCatalogItemBulkUpdateJob []string) ApiGetUpdateItemsJobsRequest {
	r.fieldsCatalogItemBulkUpdateJob = &fieldsCatalogItemBulkUpdateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;equals&#x60;
func (r ApiGetUpdateItemsJobsRequest) Filter(filter string) ApiGetUpdateItemsJobsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetUpdateItemsJobsRequest) PageCursor(pageCursor string) ApiGetUpdateItemsJobsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetUpdateItemsJobsRequest) Execute() (*GetCatalogItemUpdateJobResponseCollectionCompoundDocument, *http.Response, error) {
	return r.ApiService.GetUpdateItemsJobsExecute(r)
}

/*
GetUpdateItemsJobs Get Update Items Jobs

Get all catalog item bulk update jobs.

Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUpdateItemsJobsRequest
*/
func (a *CatalogsAPIService) GetUpdateItemsJobs(ctx context.Context) ApiGetUpdateItemsJobsRequest {
	return ApiGetUpdateItemsJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogItemUpdateJobResponseCollectionCompoundDocument
func (a *CatalogsAPIService) GetUpdateItemsJobsExecute(r ApiGetUpdateItemsJobsRequest) (*GetCatalogItemUpdateJobResponseCollectionCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogItemUpdateJobResponseCollectionCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetUpdateItemsJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-item-bulk-update-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogItemBulkUpdateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-item-bulk-update-job]", r.fieldsCatalogItemBulkUpdateJob, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpdateVariantsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	jobId string
	revision *string
	fieldsCatalogVariantBulkUpdateJob *[]string
	fieldsCatalogVariant *[]string
	include *[]string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetUpdateVariantsJobRequest) Revision(revision string) ApiGetUpdateVariantsJobRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetUpdateVariantsJobRequest) FieldsCatalogVariantBulkUpdateJob(fieldsCatalogVariantBulkUpdateJob []string) ApiGetUpdateVariantsJobRequest {
	r.fieldsCatalogVariantBulkUpdateJob = &fieldsCatalogVariantBulkUpdateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetUpdateVariantsJobRequest) FieldsCatalogVariant(fieldsCatalogVariant []string) ApiGetUpdateVariantsJobRequest {
	r.fieldsCatalogVariant = &fieldsCatalogVariant
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#relationships
func (r ApiGetUpdateVariantsJobRequest) Include(include []string) ApiGetUpdateVariantsJobRequest {
	r.include = &include
	return r
}

func (r ApiGetUpdateVariantsJobRequest) Execute() (*GetCatalogVariantUpdateJobResponseCompoundDocument, *http.Response, error) {
	return r.ApiService.GetUpdateVariantsJobExecute(r)
}

/*
GetUpdateVariantsJob Get Update Variants Job

Get a catalog variate bulk update job with the given job ID.

An `include` parameter can be provided to get the following related resource data: `variants`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId ID of the job to retrieve.
 @return ApiGetUpdateVariantsJobRequest
*/
func (a *CatalogsAPIService) GetUpdateVariantsJob(ctx context.Context, jobId string) ApiGetUpdateVariantsJobRequest {
	return ApiGetUpdateVariantsJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return GetCatalogVariantUpdateJobResponseCompoundDocument
func (a *CatalogsAPIService) GetUpdateVariantsJobExecute(r ApiGetUpdateVariantsJobRequest) (*GetCatalogVariantUpdateJobResponseCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogVariantUpdateJobResponseCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetUpdateVariantsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variant-bulk-update-jobs/{job_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogVariantBulkUpdateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant-bulk-update-job]", r.fieldsCatalogVariantBulkUpdateJob, "csv")
	}
	if r.fieldsCatalogVariant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant]", r.fieldsCatalogVariant, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpdateVariantsJobsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	fieldsCatalogVariantBulkUpdateJob *[]string
	filter *string
	pageCursor *string
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiGetUpdateVariantsJobsRequest) Revision(revision string) ApiGetUpdateVariantsJobsRequest {
	r.revision = &revision
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#sparse-fieldsets
func (r ApiGetUpdateVariantsJobsRequest) FieldsCatalogVariantBulkUpdateJob(fieldsCatalogVariantBulkUpdateJob []string) ApiGetUpdateVariantsJobsRequest {
	r.fieldsCatalogVariantBulkUpdateJob = &fieldsCatalogVariantBulkUpdateJob
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;equals&#x60;
func (r ApiGetUpdateVariantsJobsRequest) Filter(filter string) ApiGetUpdateVariantsJobsRequest {
	r.filter = &filter
	return r
}

// For more information please visit https://developers.klaviyo.com/en/v2024-02-15/reference/api-overview#pagination
func (r ApiGetUpdateVariantsJobsRequest) PageCursor(pageCursor string) ApiGetUpdateVariantsJobsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetUpdateVariantsJobsRequest) Execute() (*GetCatalogVariantUpdateJobResponseCollectionCompoundDocument, *http.Response, error) {
	return r.ApiService.GetUpdateVariantsJobsExecute(r)
}

/*
GetUpdateVariantsJobs Get Update Variants Jobs

Get all catalog variant bulk update jobs.

Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUpdateVariantsJobsRequest
*/
func (a *CatalogsAPIService) GetUpdateVariantsJobs(ctx context.Context) ApiGetUpdateVariantsJobsRequest {
	return ApiGetUpdateVariantsJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCatalogVariantUpdateJobResponseCollectionCompoundDocument
func (a *CatalogsAPIService) GetUpdateVariantsJobsExecute(r ApiGetUpdateVariantsJobsRequest) (*GetCatalogVariantUpdateJobResponseCollectionCompoundDocument, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCatalogVariantUpdateJobResponseCollectionCompoundDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.GetUpdateVariantsJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variant-bulk-update-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}

	if r.fieldsCatalogVariantBulkUpdateJob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[catalog-variant-bulk-update-job]", r.fieldsCatalogVariantBulkUpdateJob, "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[cursor]", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpawnCreateCategoriesJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogCategoryCreateJobCreateQuery *CatalogCategoryCreateJobCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiSpawnCreateCategoriesJobRequest) Revision(revision string) ApiSpawnCreateCategoriesJobRequest {
	r.revision = &revision
	return r
}

func (r ApiSpawnCreateCategoriesJobRequest) CatalogCategoryCreateJobCreateQuery(catalogCategoryCreateJobCreateQuery CatalogCategoryCreateJobCreateQuery) ApiSpawnCreateCategoriesJobRequest {
	r.catalogCategoryCreateJobCreateQuery = &catalogCategoryCreateJobCreateQuery
	return r
}

func (r ApiSpawnCreateCategoriesJobRequest) Execute() (*PostCatalogCategoryCreateJobResponse, *http.Response, error) {
	return r.ApiService.SpawnCreateCategoriesJobExecute(r)
}

/*
SpawnCreateCategoriesJob Spawn Create Categories Job

Create a catalog category bulk create job to create a batch of catalog categories.

Accepts up to 100 catalog categories per request. The maximum allowed payload size is 5MB.
The maximum number of jobs in progress at one time is 500.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpawnCreateCategoriesJobRequest
*/
func (a *CatalogsAPIService) SpawnCreateCategoriesJob(ctx context.Context) ApiSpawnCreateCategoriesJobRequest {
	return ApiSpawnCreateCategoriesJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogCategoryCreateJobResponse
func (a *CatalogsAPIService) SpawnCreateCategoriesJobExecute(r ApiSpawnCreateCategoriesJobRequest) (*PostCatalogCategoryCreateJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogCategoryCreateJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.SpawnCreateCategoriesJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-category-bulk-create-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogCategoryCreateJobCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogCategoryCreateJobCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogCategoryCreateJobCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpawnCreateItemsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogItemCreateJobCreateQuery *CatalogItemCreateJobCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiSpawnCreateItemsJobRequest) Revision(revision string) ApiSpawnCreateItemsJobRequest {
	r.revision = &revision
	return r
}

func (r ApiSpawnCreateItemsJobRequest) CatalogItemCreateJobCreateQuery(catalogItemCreateJobCreateQuery CatalogItemCreateJobCreateQuery) ApiSpawnCreateItemsJobRequest {
	r.catalogItemCreateJobCreateQuery = &catalogItemCreateJobCreateQuery
	return r
}

func (r ApiSpawnCreateItemsJobRequest) Execute() (*PostCatalogItemCreateJobResponse, *http.Response, error) {
	return r.ApiService.SpawnCreateItemsJobExecute(r)
}

/*
SpawnCreateItemsJob Spawn Create Items Job

Create a catalog item bulk create job to create a batch of catalog items.

Accepts up to 100 catalog items per request. The maximum allowed payload size is 5MB.
The maximum number of jobs in progress at one time is 500.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpawnCreateItemsJobRequest
*/
func (a *CatalogsAPIService) SpawnCreateItemsJob(ctx context.Context) ApiSpawnCreateItemsJobRequest {
	return ApiSpawnCreateItemsJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogItemCreateJobResponse
func (a *CatalogsAPIService) SpawnCreateItemsJobExecute(r ApiSpawnCreateItemsJobRequest) (*PostCatalogItemCreateJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogItemCreateJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.SpawnCreateItemsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-item-bulk-create-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogItemCreateJobCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogItemCreateJobCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogItemCreateJobCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpawnCreateVariantsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogVariantCreateJobCreateQuery *CatalogVariantCreateJobCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiSpawnCreateVariantsJobRequest) Revision(revision string) ApiSpawnCreateVariantsJobRequest {
	r.revision = &revision
	return r
}

func (r ApiSpawnCreateVariantsJobRequest) CatalogVariantCreateJobCreateQuery(catalogVariantCreateJobCreateQuery CatalogVariantCreateJobCreateQuery) ApiSpawnCreateVariantsJobRequest {
	r.catalogVariantCreateJobCreateQuery = &catalogVariantCreateJobCreateQuery
	return r
}

func (r ApiSpawnCreateVariantsJobRequest) Execute() (*PostCatalogVariantCreateJobResponse, *http.Response, error) {
	return r.ApiService.SpawnCreateVariantsJobExecute(r)
}

/*
SpawnCreateVariantsJob Spawn Create Variants Job

Create a catalog variant bulk create job to create a batch of catalog variants.

Accepts up to 100 catalog variants per request. The maximum allowed payload size is 5MB.
The maximum number of jobs in progress at one time is 500.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpawnCreateVariantsJobRequest
*/
func (a *CatalogsAPIService) SpawnCreateVariantsJob(ctx context.Context) ApiSpawnCreateVariantsJobRequest {
	return ApiSpawnCreateVariantsJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogVariantCreateJobResponse
func (a *CatalogsAPIService) SpawnCreateVariantsJobExecute(r ApiSpawnCreateVariantsJobRequest) (*PostCatalogVariantCreateJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogVariantCreateJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.SpawnCreateVariantsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variant-bulk-create-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogVariantCreateJobCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogVariantCreateJobCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogVariantCreateJobCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpawnDeleteCategoriesJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogCategoryDeleteJobCreateQuery *CatalogCategoryDeleteJobCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiSpawnDeleteCategoriesJobRequest) Revision(revision string) ApiSpawnDeleteCategoriesJobRequest {
	r.revision = &revision
	return r
}

func (r ApiSpawnDeleteCategoriesJobRequest) CatalogCategoryDeleteJobCreateQuery(catalogCategoryDeleteJobCreateQuery CatalogCategoryDeleteJobCreateQuery) ApiSpawnDeleteCategoriesJobRequest {
	r.catalogCategoryDeleteJobCreateQuery = &catalogCategoryDeleteJobCreateQuery
	return r
}

func (r ApiSpawnDeleteCategoriesJobRequest) Execute() (*PostCatalogCategoryDeleteJobResponse, *http.Response, error) {
	return r.ApiService.SpawnDeleteCategoriesJobExecute(r)
}

/*
SpawnDeleteCategoriesJob Spawn Delete Categories Job

Create a catalog category bulk delete job to delete a batch of catalog categories.

Accepts up to 100 catalog categories per request. The maximum allowed payload size is 5MB.
The maximum number of jobs in progress at one time is 500.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpawnDeleteCategoriesJobRequest
*/
func (a *CatalogsAPIService) SpawnDeleteCategoriesJob(ctx context.Context) ApiSpawnDeleteCategoriesJobRequest {
	return ApiSpawnDeleteCategoriesJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogCategoryDeleteJobResponse
func (a *CatalogsAPIService) SpawnDeleteCategoriesJobExecute(r ApiSpawnDeleteCategoriesJobRequest) (*PostCatalogCategoryDeleteJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogCategoryDeleteJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.SpawnDeleteCategoriesJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-category-bulk-delete-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogCategoryDeleteJobCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogCategoryDeleteJobCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogCategoryDeleteJobCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpawnDeleteItemsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogItemDeleteJobCreateQuery *CatalogItemDeleteJobCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiSpawnDeleteItemsJobRequest) Revision(revision string) ApiSpawnDeleteItemsJobRequest {
	r.revision = &revision
	return r
}

func (r ApiSpawnDeleteItemsJobRequest) CatalogItemDeleteJobCreateQuery(catalogItemDeleteJobCreateQuery CatalogItemDeleteJobCreateQuery) ApiSpawnDeleteItemsJobRequest {
	r.catalogItemDeleteJobCreateQuery = &catalogItemDeleteJobCreateQuery
	return r
}

func (r ApiSpawnDeleteItemsJobRequest) Execute() (*PostCatalogItemDeleteJobResponse, *http.Response, error) {
	return r.ApiService.SpawnDeleteItemsJobExecute(r)
}

/*
SpawnDeleteItemsJob Spawn Delete Items Job

Create a catalog item bulk delete job to delete a batch of catalog items.

Accepts up to 100 catalog items per request. The maximum allowed payload size is 5MB.
The maximum number of jobs in progress at one time is 500.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpawnDeleteItemsJobRequest
*/
func (a *CatalogsAPIService) SpawnDeleteItemsJob(ctx context.Context) ApiSpawnDeleteItemsJobRequest {
	return ApiSpawnDeleteItemsJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogItemDeleteJobResponse
func (a *CatalogsAPIService) SpawnDeleteItemsJobExecute(r ApiSpawnDeleteItemsJobRequest) (*PostCatalogItemDeleteJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogItemDeleteJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.SpawnDeleteItemsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-item-bulk-delete-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogItemDeleteJobCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogItemDeleteJobCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogItemDeleteJobCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpawnDeleteVariantsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogVariantDeleteJobCreateQuery *CatalogVariantDeleteJobCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiSpawnDeleteVariantsJobRequest) Revision(revision string) ApiSpawnDeleteVariantsJobRequest {
	r.revision = &revision
	return r
}

func (r ApiSpawnDeleteVariantsJobRequest) CatalogVariantDeleteJobCreateQuery(catalogVariantDeleteJobCreateQuery CatalogVariantDeleteJobCreateQuery) ApiSpawnDeleteVariantsJobRequest {
	r.catalogVariantDeleteJobCreateQuery = &catalogVariantDeleteJobCreateQuery
	return r
}

func (r ApiSpawnDeleteVariantsJobRequest) Execute() (*PostCatalogVariantDeleteJobResponse, *http.Response, error) {
	return r.ApiService.SpawnDeleteVariantsJobExecute(r)
}

/*
SpawnDeleteVariantsJob Spawn Delete Variants Job

Create a catalog variant bulk delete job to delete a batch of catalog variants.

Accepts up to 100 catalog variants per request. The maximum allowed payload size is 5MB.
The maximum number of jobs in progress at one time is 500.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpawnDeleteVariantsJobRequest
*/
func (a *CatalogsAPIService) SpawnDeleteVariantsJob(ctx context.Context) ApiSpawnDeleteVariantsJobRequest {
	return ApiSpawnDeleteVariantsJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogVariantDeleteJobResponse
func (a *CatalogsAPIService) SpawnDeleteVariantsJobExecute(r ApiSpawnDeleteVariantsJobRequest) (*PostCatalogVariantDeleteJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogVariantDeleteJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.SpawnDeleteVariantsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variant-bulk-delete-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogVariantDeleteJobCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogVariantDeleteJobCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogVariantDeleteJobCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpawnUpdateCategoriesJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogCategoryUpdateJobCreateQuery *CatalogCategoryUpdateJobCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiSpawnUpdateCategoriesJobRequest) Revision(revision string) ApiSpawnUpdateCategoriesJobRequest {
	r.revision = &revision
	return r
}

func (r ApiSpawnUpdateCategoriesJobRequest) CatalogCategoryUpdateJobCreateQuery(catalogCategoryUpdateJobCreateQuery CatalogCategoryUpdateJobCreateQuery) ApiSpawnUpdateCategoriesJobRequest {
	r.catalogCategoryUpdateJobCreateQuery = &catalogCategoryUpdateJobCreateQuery
	return r
}

func (r ApiSpawnUpdateCategoriesJobRequest) Execute() (*PostCatalogCategoryUpdateJobResponse, *http.Response, error) {
	return r.ApiService.SpawnUpdateCategoriesJobExecute(r)
}

/*
SpawnUpdateCategoriesJob Spawn Update Categories Job

Create a catalog category bulk update job to update a batch of catalog categories.

Accepts up to 100 catalog categories per request. The maximum allowed payload size is 5MB.
The maximum number of jobs in progress at one time is 500.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpawnUpdateCategoriesJobRequest
*/
func (a *CatalogsAPIService) SpawnUpdateCategoriesJob(ctx context.Context) ApiSpawnUpdateCategoriesJobRequest {
	return ApiSpawnUpdateCategoriesJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogCategoryUpdateJobResponse
func (a *CatalogsAPIService) SpawnUpdateCategoriesJobExecute(r ApiSpawnUpdateCategoriesJobRequest) (*PostCatalogCategoryUpdateJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogCategoryUpdateJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.SpawnUpdateCategoriesJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-category-bulk-update-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogCategoryUpdateJobCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogCategoryUpdateJobCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogCategoryUpdateJobCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpawnUpdateItemsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogItemUpdateJobCreateQuery *CatalogItemUpdateJobCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiSpawnUpdateItemsJobRequest) Revision(revision string) ApiSpawnUpdateItemsJobRequest {
	r.revision = &revision
	return r
}

func (r ApiSpawnUpdateItemsJobRequest) CatalogItemUpdateJobCreateQuery(catalogItemUpdateJobCreateQuery CatalogItemUpdateJobCreateQuery) ApiSpawnUpdateItemsJobRequest {
	r.catalogItemUpdateJobCreateQuery = &catalogItemUpdateJobCreateQuery
	return r
}

func (r ApiSpawnUpdateItemsJobRequest) Execute() (*PostCatalogItemUpdateJobResponse, *http.Response, error) {
	return r.ApiService.SpawnUpdateItemsJobExecute(r)
}

/*
SpawnUpdateItemsJob Spawn Update Items Job

Create a catalog item bulk update job to update a batch of catalog items.

Accepts up to 100 catalog items per request. The maximum allowed payload size is 5MB.
The maximum number of jobs in progress at one time is 500.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpawnUpdateItemsJobRequest
*/
func (a *CatalogsAPIService) SpawnUpdateItemsJob(ctx context.Context) ApiSpawnUpdateItemsJobRequest {
	return ApiSpawnUpdateItemsJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogItemUpdateJobResponse
func (a *CatalogsAPIService) SpawnUpdateItemsJobExecute(r ApiSpawnUpdateItemsJobRequest) (*PostCatalogItemUpdateJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogItemUpdateJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.SpawnUpdateItemsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-item-bulk-update-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogItemUpdateJobCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogItemUpdateJobCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogItemUpdateJobCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpawnUpdateVariantsJobRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	revision *string
	catalogVariantUpdateJobCreateQuery *CatalogVariantUpdateJobCreateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiSpawnUpdateVariantsJobRequest) Revision(revision string) ApiSpawnUpdateVariantsJobRequest {
	r.revision = &revision
	return r
}

func (r ApiSpawnUpdateVariantsJobRequest) CatalogVariantUpdateJobCreateQuery(catalogVariantUpdateJobCreateQuery CatalogVariantUpdateJobCreateQuery) ApiSpawnUpdateVariantsJobRequest {
	r.catalogVariantUpdateJobCreateQuery = &catalogVariantUpdateJobCreateQuery
	return r
}

func (r ApiSpawnUpdateVariantsJobRequest) Execute() (*PostCatalogVariantUpdateJobResponse, *http.Response, error) {
	return r.ApiService.SpawnUpdateVariantsJobExecute(r)
}

/*
SpawnUpdateVariantsJob Spawn Update Variants Job

Create a catalog variant bulk update job to update a batch of catalog variants.

Accepts up to 100 catalog variants per request. The maximum allowed payload size is 5MB.
The maximum number of jobs in progress at one time is 500.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpawnUpdateVariantsJobRequest
*/
func (a *CatalogsAPIService) SpawnUpdateVariantsJob(ctx context.Context) ApiSpawnUpdateVariantsJobRequest {
	return ApiSpawnUpdateVariantsJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostCatalogVariantUpdateJobResponse
func (a *CatalogsAPIService) SpawnUpdateVariantsJobExecute(r ApiSpawnUpdateVariantsJobRequest) (*PostCatalogVariantUpdateJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostCatalogVariantUpdateJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.SpawnUpdateVariantsJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variant-bulk-update-jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogVariantUpdateJobCreateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogVariantUpdateJobCreateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogVariantUpdateJobCreateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCatalogCategoryRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	catalogCategoryUpdateQuery *CatalogCategoryUpdateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiUpdateCatalogCategoryRequest) Revision(revision string) ApiUpdateCatalogCategoryRequest {
	r.revision = &revision
	return r
}

func (r ApiUpdateCatalogCategoryRequest) CatalogCategoryUpdateQuery(catalogCategoryUpdateQuery CatalogCategoryUpdateQuery) ApiUpdateCatalogCategoryRequest {
	r.catalogCategoryUpdateQuery = &catalogCategoryUpdateQuery
	return r
}

func (r ApiUpdateCatalogCategoryRequest) Execute() (*PatchCatalogCategoryResponse, *http.Response, error) {
	return r.ApiService.UpdateCatalogCategoryExecute(r)
}

/*
UpdateCatalogCategory Update Catalog Category

Update a catalog category with the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The catalog category ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
 @return ApiUpdateCatalogCategoryRequest
*/
func (a *CatalogsAPIService) UpdateCatalogCategory(ctx context.Context, id string) ApiUpdateCatalogCategoryRequest {
	return ApiUpdateCatalogCategoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PatchCatalogCategoryResponse
func (a *CatalogsAPIService) UpdateCatalogCategoryExecute(r ApiUpdateCatalogCategoryRequest) (*PatchCatalogCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchCatalogCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.UpdateCatalogCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-categories/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogCategoryUpdateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogCategoryUpdateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogCategoryUpdateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCatalogCategoryRelationshipsItemsRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	catalogCategoryItemOp *CatalogCategoryItemOp
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiUpdateCatalogCategoryRelationshipsItemsRequest) Revision(revision string) ApiUpdateCatalogCategoryRelationshipsItemsRequest {
	r.revision = &revision
	return r
}

func (r ApiUpdateCatalogCategoryRelationshipsItemsRequest) CatalogCategoryItemOp(catalogCategoryItemOp CatalogCategoryItemOp) ApiUpdateCatalogCategoryRelationshipsItemsRequest {
	r.catalogCategoryItemOp = &catalogCategoryItemOp
	return r
}

func (r ApiUpdateCatalogCategoryRelationshipsItemsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCatalogCategoryRelationshipsItemsExecute(r)
}

/*
UpdateCatalogCategoryRelationshipsItems Update Catalog Category Relationships Items

Update item relationships for the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiUpdateCatalogCategoryRelationshipsItemsRequest
*/
func (a *CatalogsAPIService) UpdateCatalogCategoryRelationshipsItems(ctx context.Context, id string) ApiUpdateCatalogCategoryRelationshipsItemsRequest {
	return ApiUpdateCatalogCategoryRelationshipsItemsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CatalogsAPIService) UpdateCatalogCategoryRelationshipsItemsExecute(r ApiUpdateCatalogCategoryRelationshipsItemsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.UpdateCatalogCategoryRelationshipsItems")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-categories/{id}/relationships/items/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.catalogCategoryItemOp == nil {
		return nil, reportError("catalogCategoryItemOp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogCategoryItemOp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCatalogItemRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	catalogItemUpdateQuery *CatalogItemUpdateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiUpdateCatalogItemRequest) Revision(revision string) ApiUpdateCatalogItemRequest {
	r.revision = &revision
	return r
}

func (r ApiUpdateCatalogItemRequest) CatalogItemUpdateQuery(catalogItemUpdateQuery CatalogItemUpdateQuery) ApiUpdateCatalogItemRequest {
	r.catalogItemUpdateQuery = &catalogItemUpdateQuery
	return r
}

func (r ApiUpdateCatalogItemRequest) Execute() (*PatchCatalogItemResponse, *http.Response, error) {
	return r.ApiService.UpdateCatalogItemExecute(r)
}

/*
UpdateCatalogItem Update Catalog Item

Update a catalog item with the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The catalog item ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
 @return ApiUpdateCatalogItemRequest
*/
func (a *CatalogsAPIService) UpdateCatalogItem(ctx context.Context, id string) ApiUpdateCatalogItemRequest {
	return ApiUpdateCatalogItemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PatchCatalogItemResponse
func (a *CatalogsAPIService) UpdateCatalogItemExecute(r ApiUpdateCatalogItemRequest) (*PatchCatalogItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchCatalogItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.UpdateCatalogItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogItemUpdateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogItemUpdateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogItemUpdateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCatalogItemRelationshipsCategoriesRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	catalogItemCategoryOp *CatalogItemCategoryOp
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiUpdateCatalogItemRelationshipsCategoriesRequest) Revision(revision string) ApiUpdateCatalogItemRelationshipsCategoriesRequest {
	r.revision = &revision
	return r
}

func (r ApiUpdateCatalogItemRelationshipsCategoriesRequest) CatalogItemCategoryOp(catalogItemCategoryOp CatalogItemCategoryOp) ApiUpdateCatalogItemRelationshipsCategoriesRequest {
	r.catalogItemCategoryOp = &catalogItemCategoryOp
	return r
}

func (r ApiUpdateCatalogItemRelationshipsCategoriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCatalogItemRelationshipsCategoriesExecute(r)
}

/*
UpdateCatalogItemRelationshipsCategories Update Catalog Item Relationships Categories

Update catalog category relationships for the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiUpdateCatalogItemRelationshipsCategoriesRequest
*/
func (a *CatalogsAPIService) UpdateCatalogItemRelationshipsCategories(ctx context.Context, id string) ApiUpdateCatalogItemRelationshipsCategoriesRequest {
	return ApiUpdateCatalogItemRelationshipsCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CatalogsAPIService) UpdateCatalogItemRelationshipsCategoriesExecute(r ApiUpdateCatalogItemRelationshipsCategoriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.UpdateCatalogItemRelationshipsCategories")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-items/{id}/relationships/categories/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.catalogItemCategoryOp == nil {
		return nil, reportError("catalogItemCategoryOp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogItemCategoryOp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCatalogVariantRequest struct {
	ctx context.Context
	ApiService *CatalogsAPIService
	id string
	revision *string
	catalogVariantUpdateQuery *CatalogVariantUpdateQuery
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiUpdateCatalogVariantRequest) Revision(revision string) ApiUpdateCatalogVariantRequest {
	r.revision = &revision
	return r
}

func (r ApiUpdateCatalogVariantRequest) CatalogVariantUpdateQuery(catalogVariantUpdateQuery CatalogVariantUpdateQuery) ApiUpdateCatalogVariantRequest {
	r.catalogVariantUpdateQuery = &catalogVariantUpdateQuery
	return r
}

func (r ApiUpdateCatalogVariantRequest) Execute() (*PatchCatalogVariantResponse, *http.Response, error) {
	return r.ApiService.UpdateCatalogVariantExecute(r)
}

/*
UpdateCatalogVariant Update Catalog Variant

Update a catalog item variant with the given variant ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

**Scopes:**
`catalogs:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The catalog variant ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
 @return ApiUpdateCatalogVariantRequest
*/
func (a *CatalogsAPIService) UpdateCatalogVariant(ctx context.Context, id string) ApiUpdateCatalogVariantRequest {
	return ApiUpdateCatalogVariantRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PatchCatalogVariantResponse
func (a *CatalogsAPIService) UpdateCatalogVariantExecute(r ApiUpdateCatalogVariantRequest) (*PatchCatalogVariantResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PatchCatalogVariantResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsAPIService.UpdateCatalogVariant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/catalog-variants/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.revision == nil {
		return localVarReturnValue, nil, reportError("revision is required and must be specified")
	}
	if r.catalogVariantUpdateQuery == nil {
		return localVarReturnValue, nil, reportError("catalogVariantUpdateQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.catalogVariantUpdateQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Klaviyo-API-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
