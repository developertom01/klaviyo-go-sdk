/*
Klaviyo API

The Klaviyo REST API. Please visit https://developers.klaviyo.com for more details.

API version: 2024-02-15
Contact: developers@klaviyo.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package klaviyo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ClientAPIService ClientAPI service
type ClientAPIService service

type ApiBulkCreateClientEventsRequest struct {
	ctx context.Context
	ApiService *ClientAPIService
	companyId *string
	revision *string
	eventsBulkCreateQuery *EventsBulkCreateQuery
}

// Your Public API Key / Site ID. See [this article](https://help.klaviyo.com/hc/en-us/articles/115005062267) for more details.
func (r ApiBulkCreateClientEventsRequest) CompanyId(companyId string) ApiBulkCreateClientEventsRequest {
	r.companyId = &companyId
	return r
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiBulkCreateClientEventsRequest) Revision(revision string) ApiBulkCreateClientEventsRequest {
	r.revision = &revision
	return r
}

func (r ApiBulkCreateClientEventsRequest) EventsBulkCreateQuery(eventsBulkCreateQuery EventsBulkCreateQuery) ApiBulkCreateClientEventsRequest {
	r.eventsBulkCreateQuery = &eventsBulkCreateQuery
	return r
}

func (r ApiBulkCreateClientEventsRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkCreateClientEventsExecute(r)
}

/*
BulkCreateClientEvents Bulk Create Client Events

Create new events to track a profile's activity.

This endpoint is specifically designed to be called from publicly-browseable, client-side environments only.

Accepts a maximum of `1000` events per request.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

**Scopes:**
`events:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkCreateClientEventsRequest
*/
func (a *ClientAPIService) BulkCreateClientEvents(ctx context.Context) ApiBulkCreateClientEventsRequest {
	return ApiBulkCreateClientEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ClientAPIService) BulkCreateClientEventsExecute(r ApiBulkCreateClientEventsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientAPIService.BulkCreateClientEvents")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/client/event-bulk-create/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return nil, reportError("companyId is required and must be specified")
	}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.eventsBulkCreateQuery == nil {
		return nil, reportError("eventsBulkCreateQuery is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "company_id", r.companyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.eventsBulkCreateQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateClientBackInStockSubscriptionRequest struct {
	ctx context.Context
	ApiService *ClientAPIService
	companyId *string
	revision *string
	clientBISSubscriptionCreateQuery *ClientBISSubscriptionCreateQuery
}

// Your Public API Key / Site ID. See [this article](https://help.klaviyo.com/hc/en-us/articles/115005062267) for more details.
func (r ApiCreateClientBackInStockSubscriptionRequest) CompanyId(companyId string) ApiCreateClientBackInStockSubscriptionRequest {
	r.companyId = &companyId
	return r
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiCreateClientBackInStockSubscriptionRequest) Revision(revision string) ApiCreateClientBackInStockSubscriptionRequest {
	r.revision = &revision
	return r
}

func (r ApiCreateClientBackInStockSubscriptionRequest) ClientBISSubscriptionCreateQuery(clientBISSubscriptionCreateQuery ClientBISSubscriptionCreateQuery) ApiCreateClientBackInStockSubscriptionRequest {
	r.clientBISSubscriptionCreateQuery = &clientBISSubscriptionCreateQuery
	return r
}

func (r ApiCreateClientBackInStockSubscriptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateClientBackInStockSubscriptionExecute(r)
}

/*
CreateClientBackInStockSubscription Create Client Back In Stock Subscription

Subscribe a profile to receive back in stock notifications. Check out [our Back in Stock API guide](https://developers.klaviyo.com/en/docs/how_to_set_up_custom_back_in_stock) for more details.

This endpoint is specifically designed to be called from publicly-browseable, client-side environments only. To create subscriptions from server-based applications, please use [POST /api/back-in-stock-subscriptions](https://developers.klaviyo.com/en/reference/create_back_in_stock_subscription).<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`catalogs:write`
`profiles:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateClientBackInStockSubscriptionRequest
*/
func (a *ClientAPIService) CreateClientBackInStockSubscription(ctx context.Context) ApiCreateClientBackInStockSubscriptionRequest {
	return ApiCreateClientBackInStockSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ClientAPIService) CreateClientBackInStockSubscriptionExecute(r ApiCreateClientBackInStockSubscriptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientAPIService.CreateClientBackInStockSubscription")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/client/back-in-stock-subscriptions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return nil, reportError("companyId is required and must be specified")
	}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.clientBISSubscriptionCreateQuery == nil {
		return nil, reportError("clientBISSubscriptionCreateQuery is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "company_id", r.companyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.clientBISSubscriptionCreateQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateClientEventRequest struct {
	ctx context.Context
	ApiService *ClientAPIService
	companyId *string
	revision *string
	eventCreateQueryV2 *EventCreateQueryV2
}

// Your Public API Key / Site ID. See [this article](https://help.klaviyo.com/hc/en-us/articles/115005062267) for more details.
func (r ApiCreateClientEventRequest) CompanyId(companyId string) ApiCreateClientEventRequest {
	r.companyId = &companyId
	return r
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiCreateClientEventRequest) Revision(revision string) ApiCreateClientEventRequest {
	r.revision = &revision
	return r
}

func (r ApiCreateClientEventRequest) EventCreateQueryV2(eventCreateQueryV2 EventCreateQueryV2) ApiCreateClientEventRequest {
	r.eventCreateQueryV2 = &eventCreateQueryV2
	return r
}

func (r ApiCreateClientEventRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateClientEventExecute(r)
}

/*
CreateClientEvent Create Client Event

Create a new event to track a profile's activity.

This endpoint is specifically designed to be called from publicly-browseable, client-side environments only. To create events from server-based applications, please use [POST /api/events](https://developers.klaviyo.com/en/reference/create_event)<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`events:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateClientEventRequest
*/
func (a *ClientAPIService) CreateClientEvent(ctx context.Context) ApiCreateClientEventRequest {
	return ApiCreateClientEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ClientAPIService) CreateClientEventExecute(r ApiCreateClientEventRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientAPIService.CreateClientEvent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/client/events/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return nil, reportError("companyId is required and must be specified")
	}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.eventCreateQueryV2 == nil {
		return nil, reportError("eventCreateQueryV2 is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "company_id", r.companyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.eventCreateQueryV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateClientProfileRequest struct {
	ctx context.Context
	ApiService *ClientAPIService
	companyId *string
	revision *string
	onsiteProfileCreateQuery *OnsiteProfileCreateQuery
}

// Your Public API Key / Site ID. See [this article](https://help.klaviyo.com/hc/en-us/articles/115005062267) for more details.
func (r ApiCreateClientProfileRequest) CompanyId(companyId string) ApiCreateClientProfileRequest {
	r.companyId = &companyId
	return r
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiCreateClientProfileRequest) Revision(revision string) ApiCreateClientProfileRequest {
	r.revision = &revision
	return r
}

func (r ApiCreateClientProfileRequest) OnsiteProfileCreateQuery(onsiteProfileCreateQuery OnsiteProfileCreateQuery) ApiCreateClientProfileRequest {
	r.onsiteProfileCreateQuery = &onsiteProfileCreateQuery
	return r
}

func (r ApiCreateClientProfileRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateClientProfileExecute(r)
}

/*
CreateClientProfile Create or Update Client Profile

Create and update properties about a profile without tracking an associated event.

This endpoint is specifically designed to be called from publicly-browseable, client-side environments only. To create profiles from server applications (e.g. custom server-side scripts / applications), please use [POST /api/profiles](https://developers.klaviyo.com/en/reference/create_profile)<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

**Scopes:**
`profiles:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateClientProfileRequest
*/
func (a *ClientAPIService) CreateClientProfile(ctx context.Context) ApiCreateClientProfileRequest {
	return ApiCreateClientProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ClientAPIService) CreateClientProfileExecute(r ApiCreateClientProfileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientAPIService.CreateClientProfile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/client/profiles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return nil, reportError("companyId is required and must be specified")
	}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.onsiteProfileCreateQuery == nil {
		return nil, reportError("onsiteProfileCreateQuery is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "company_id", r.companyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.onsiteProfileCreateQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateClientPushTokenRequest struct {
	ctx context.Context
	ApiService *ClientAPIService
	companyId *string
	revision *string
	pushTokenCreateQuery *PushTokenCreateQuery
}

// Your Public API Key / Site ID. See [this article](https://help.klaviyo.com/hc/en-us/articles/115005062267) for more details.
func (r ApiCreateClientPushTokenRequest) CompanyId(companyId string) ApiCreateClientPushTokenRequest {
	r.companyId = &companyId
	return r
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiCreateClientPushTokenRequest) Revision(revision string) ApiCreateClientPushTokenRequest {
	r.revision = &revision
	return r
}

func (r ApiCreateClientPushTokenRequest) PushTokenCreateQuery(pushTokenCreateQuery PushTokenCreateQuery) ApiCreateClientPushTokenRequest {
	r.pushTokenCreateQuery = &pushTokenCreateQuery
	return r
}

func (r ApiCreateClientPushTokenRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateClientPushTokenExecute(r)
}

/*
CreateClientPushToken Create or Update Client Push Token

Create or update a push token.

This endpoint is designed to be called from our mobile SDKs ([iOS](https://github.com/klaviyo/klaviyo-swift-sdk) and [Android](https://github.com/klaviyo/klaviyo-android-sdk)).
You must have push notifications enabled to use this endpoint.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateClientPushTokenRequest
*/
func (a *ClientAPIService) CreateClientPushToken(ctx context.Context) ApiCreateClientPushTokenRequest {
	return ApiCreateClientPushTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ClientAPIService) CreateClientPushTokenExecute(r ApiCreateClientPushTokenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientAPIService.CreateClientPushToken")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/client/push-tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return nil, reportError("companyId is required and must be specified")
	}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.pushTokenCreateQuery == nil {
		return nil, reportError("pushTokenCreateQuery is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "company_id", r.companyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.pushTokenCreateQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateClientSubscriptionRequest struct {
	ctx context.Context
	ApiService *ClientAPIService
	companyId *string
	revision *string
	onsiteSubscriptionCreateQuery *OnsiteSubscriptionCreateQuery
}

// Your Public API Key / Site ID. See [this article](https://help.klaviyo.com/hc/en-us/articles/115005062267) for more details.
func (r ApiCreateClientSubscriptionRequest) CompanyId(companyId string) ApiCreateClientSubscriptionRequest {
	r.companyId = &companyId
	return r
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiCreateClientSubscriptionRequest) Revision(revision string) ApiCreateClientSubscriptionRequest {
	r.revision = &revision
	return r
}

// Creates a subscription and consent records for Email and or SMS channels based on the provided email and phone_number attributes respectively. One of either email or phone_number must be provided. To create a subscription and consent record for only one channel but still include the other channel as a profile property the consent channel can be provided as a top level attribute and the other channel can be included in the properties object.
func (r ApiCreateClientSubscriptionRequest) OnsiteSubscriptionCreateQuery(onsiteSubscriptionCreateQuery OnsiteSubscriptionCreateQuery) ApiCreateClientSubscriptionRequest {
	r.onsiteSubscriptionCreateQuery = &onsiteSubscriptionCreateQuery
	return r
}

func (r ApiCreateClientSubscriptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateClientSubscriptionExecute(r)
}

/*
CreateClientSubscription Create Client Subscription

*Rate limits*:<br>Burst: `100/s`<br>Steady: `700/m`

**Scopes:**
`subscriptions:write`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateClientSubscriptionRequest
*/
func (a *ClientAPIService) CreateClientSubscription(ctx context.Context) ApiCreateClientSubscriptionRequest {
	return ApiCreateClientSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ClientAPIService) CreateClientSubscriptionExecute(r ApiCreateClientSubscriptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientAPIService.CreateClientSubscription")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/client/subscriptions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return nil, reportError("companyId is required and must be specified")
	}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.onsiteSubscriptionCreateQuery == nil {
		return nil, reportError("onsiteSubscriptionCreateQuery is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "company_id", r.companyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.onsiteSubscriptionCreateQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnregisterClientPushTokenRequest struct {
	ctx context.Context
	ApiService *ClientAPIService
	companyId *string
	revision *string
	pushTokenUnregisterQuery *PushTokenUnregisterQuery
}

// Your Public API Key / Site ID. See [this article](https://help.klaviyo.com/hc/en-us/articles/115005062267) for more details.
func (r ApiUnregisterClientPushTokenRequest) CompanyId(companyId string) ApiUnregisterClientPushTokenRequest {
	r.companyId = &companyId
	return r
}

// API endpoint revision (format: YYYY-MM-DD[.suffix])
func (r ApiUnregisterClientPushTokenRequest) Revision(revision string) ApiUnregisterClientPushTokenRequest {
	r.revision = &revision
	return r
}

func (r ApiUnregisterClientPushTokenRequest) PushTokenUnregisterQuery(pushTokenUnregisterQuery PushTokenUnregisterQuery) ApiUnregisterClientPushTokenRequest {
	r.pushTokenUnregisterQuery = &pushTokenUnregisterQuery
	return r
}

func (r ApiUnregisterClientPushTokenRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnregisterClientPushTokenExecute(r)
}

/*
UnregisterClientPushToken Unregister Client Push Token

Unregister a push token.

This endpoint is designed to be called from our mobile SDKs ([iOS](https://github.com/klaviyo/klaviyo-swift-sdk) and [Android](https://github.com/klaviyo/klaviyo-android-sdk)).
You must have push notifications enabled to use this endpoint.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnregisterClientPushTokenRequest
*/
func (a *ClientAPIService) UnregisterClientPushToken(ctx context.Context) ApiUnregisterClientPushTokenRequest {
	return ApiUnregisterClientPushTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ClientAPIService) UnregisterClientPushTokenExecute(r ApiUnregisterClientPushTokenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientAPIService.UnregisterClientPushToken")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/client/push-token-unregister/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return nil, reportError("companyId is required and must be specified")
	}
	if r.revision == nil {
		return nil, reportError("revision is required and must be specified")
	}
	if r.pushTokenUnregisterQuery == nil {
		return nil, reportError("pushTokenUnregisterQuery is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "company_id", r.companyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "revision", r.revision, "")
	// body params
	localVarPostBody = r.pushTokenUnregisterQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v GetAccounts4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
